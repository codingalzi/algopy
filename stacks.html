
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>7. 기초 추상 자료형 1부: 스택 &#8212; 문제해결 알고리즘</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8. 기초 추상 자료형 구현 2부: 큐" href="queues.html" />
    <link rel="prev" title="6. 알고리즘 분석 2부: 파이썬 모음 자료형 분석" href="python_list_dict.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">문제해결 알고리즘</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="python_basic_1.html">
   1. 파이썬 기초 1부: 자료형
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="python_basic_2.html">
   2. 파이썬 기초 2부: 제어 구조와 함수
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="python_basic_3.html">
   3. 파이썬 기초 3부: 클래스와 상속
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="python_basic_4.html">
   4. 파이썬 기초 4부: 클래스 기본 요소
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="time_complexity.html">
   5. 알고리즘 분석 1부: 시간 복잡도
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="python_list_dict.html">
   6. 알고리즘 분석 2부: 파이썬 모음 자료형 분석
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   7. 기초 추상 자료형 1부: 스택
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="queues.html">
   8. 기초 추상 자료형 구현 2부: 큐
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="deques.html">
   9. 기초 추상 자료형 구현 3부: 덱
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linked_lists.html">
   10. 기초 추상 자료형 구현 4부: 연결 리스트
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ordered_lists.html">
   11. 기초 추상 자료형 구현 5부: 정렬 리스트
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="recursion_1.html">
   12. 재귀 1부: 재귀 함수
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="recursion_2.html">
   13. 재귀 2부: 하노이의 탑과 미로게임
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/codingalzi/algopy/master?urlpath=tree/jupyter-book/stacks.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/codingalzi/algopy"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/codingalzi/algopy/issues/new?title=Issue%20on%20page%20%2Fstacks.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/stacks.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   7.1. 스택
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#stack">
     7.1.1.
     <code class="docutils literal notranslate">
      <span class="pre">
       Stack
      </span>
     </code>
     추상 자료형
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     7.1.2. 스택 자료구조 구현
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id4">
       7.1.2.1. 확인하기
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     7.1.3. 실전 예제 1: 괄호 짝맞추기 문제
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     7.1.4. 실전 예제 2: 괄호 짝맞추기 문제(일반화)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id7">
     7.1.5. 실전 예제 3: 이진법 계산
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     7.1.6. 실전 예제 4: 진법 변환
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#infix-prefix-and-postfix-expressions">
   7.2. 4.9 Infix, Prefix, and Postfix Expressions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conversion-of-infix-expressions-to-prefix-and-postfix">
     7.2.1. 4.9.1 Conversion of Infix Expressions to Prefix and Postfix
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#general-infix-to-postfix-conversion">
     7.2.2. 4.9.2 General Infix-to-Postfix Conversion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#postfix-evaluation">
     7.2.3. 4.9.3 Postfix Evaluation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#discussion-questions">
     7.2.4. Discussion Questions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     7.2.5. 프로그래밍 실습 문제
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id10">
       7.2.5.1. 괄호 짝맞추기
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id11">
       7.2.5.2. 전위, 중위, 후위 표기법
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>기초 추상 자료형 1부: 스택</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   7.1. 스택
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#stack">
     7.1.1.
     <code class="docutils literal notranslate">
      <span class="pre">
       Stack
      </span>
     </code>
     추상 자료형
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     7.1.2. 스택 자료구조 구현
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id4">
       7.1.2.1. 확인하기
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     7.1.3. 실전 예제 1: 괄호 짝맞추기 문제
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     7.1.4. 실전 예제 2: 괄호 짝맞추기 문제(일반화)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id7">
     7.1.5. 실전 예제 3: 이진법 계산
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id8">
     7.1.6. 실전 예제 4: 진법 변환
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#infix-prefix-and-postfix-expressions">
   7.2. 4.9 Infix, Prefix, and Postfix Expressions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conversion-of-infix-expressions-to-prefix-and-postfix">
     7.2.1. 4.9.1 Conversion of Infix Expressions to Prefix and Postfix
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#general-infix-to-postfix-conversion">
     7.2.2. 4.9.2 General Infix-to-Postfix Conversion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#postfix-evaluation">
     7.2.3. 4.9.3 Postfix Evaluation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#discussion-questions">
     7.2.4. Discussion Questions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id9">
     7.2.5. 프로그래밍 실습 문제
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id10">
       7.2.5.1. 괄호 짝맞추기
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id11">
       7.2.5.2. 전위, 중위, 후위 표기법
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1><span class="section-number">7. </span>기초 추상 자료형 1부: 스택<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h1>
<p>Copyright (C)  Brad Miller, David Ranum.
This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit <a class="reference external" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">http://creativecommons.org/licenses/by-nc-sa/4.0/</a>.</p>
<p>모음 자료형 중에서
항목들이 더해지거나 삭제된 순서를 중요한 네 개의
<strong>선형 자료형</strong>(linear structures))을 살펴본다.</p>
<ul class="simple">
<li><p><strong>스택</strong>(stack)</p></li>
<li><p><strong>큐</strong>(queue)</p></li>
<li><p><strong>덱</strong>(deque)</p></li>
<li><p><strong>리스트</strong>(list)</p></li>
</ul>
<p>언급된 네 자료형 모두 두 개의 끝을 가지며
자료형에 따라 항목이 더해질 수 있는 위치와 방법이 다르다.
자료형 마다 양 끝을 이름이 다를 수 있으며 보통 처음/끝, 왼쪽/오른쪽, 전방/후방, 탑/바톰 등
다양한 방식으로 부른다.</p>
<section id="id2">
<h2><span class="section-number">7.1. </span>스택<a class="headerlink" href="#id2" title="Permalink to this headline">#</a></h2>
<p><strong>스택</strong>(stack)은 여러 개의 값을 가지며 값들 사이의 순서가 중요한 선형 자료형이다.
항목의 추가 및 삭제는 보통 <strong>탑</strong>(top)이라 불리는 한 쪽 끝에서만 허용된다.
반면에 다른 한 쪽 끝은 <strong>베이스</strong>(base)라 한다.</p>
<ul class="simple">
<li><p>베이스: 가장 먼저 추가된 항목</p></li>
<li><p>탑: 가장 나중에 추가된 항목이며 동시에 가장 먼저 삭제될 대상</p></li>
</ul>
<figure>
<div align="center"><img src="https://runestone.academy/runestone/books/published/pythonds3/_images/primitive.png" width="50%"></div>
</figure><p><strong>LIFO</strong>(last-in first-out)</p>
<p>아래 그림에서 설명된 것처럼 들어온 순서 역순으로 삭제되는 것을 의미한다.</p>
<figure>
<div align="center"><img src="https://runestone.academy/runestone/books/published/pythonds3/_images/simplereversal.png" width="70%"></div>
</figure><p><strong>활용 예제</strong>: 인터넷 브라우저의 ‘뒤로가기’(Back) 버튼</p>
<p>웹페이지가 변경될 때마다 순서를 기억해 둔 다음에
‘뒤로가기’ 버튼을 누르면 역순으로 이전 웹페이지를 보여준다.</p>
<section id="stack">
<h3><span class="section-number">7.1.1. </span><code class="docutils literal notranslate"><span class="pre">Stack</span></code> 추상 자료형<a class="headerlink" href="#stack" title="Permalink to this headline">#</a></h3>
<p>스택 추상 자료형을 구체적인 파이썬 자료구조(data structure)로
구현하려면 갖추어야 하는 기본 속성과 기능은 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Stack()</span></code>: 비어 있는 스택 생성. 생성작의 역할.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">push(item)</span></code>: 새로운 항목을 탑(top)으로 추가</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pop()</span></code>: 탑 항목 삭제. 삭제된 항목 반환.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">peek()</span></code>: 탑 항목 반환. 하지만 삭제하진 않음.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_empty()</span></code>: 스택이 비었는 여부 판단. 부울값 반환.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size()</span></code>:  항목 개수 반환.</p></li>
</ul>
<p>아래 테이블은 스택 생성과 함께 다양한 스택 관련 연산의 작동법을 소개한다.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>스택 연산</p></th>
<th class="head"><p>스택 항목</p></th>
<th class="head"><p>반환값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">Stack()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[]</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.is_empty()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.push(4)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4]</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.push('dog')</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog']</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.peek()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog']</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'dog'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.push(True)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog',</span> <span class="pre">True]</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.size()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog',</span> <span class="pre">True]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">3</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.is_empty()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog',</span> <span class="pre">True]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.push(8.4)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog',</span> <span class="pre">True,</span> <span class="pre">8.4]</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.pop()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog',</span> <span class="pre">True]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">8.4</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.pop()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog']</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.size()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">'dog']</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">2</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="id3">
<h3><span class="section-number">7.1.2. </span>스택 자료구조 구현<a class="headerlink" href="#id3" title="Permalink to this headline">#</a></h3>
<p>스택 자료구조를 <code class="docutils literal notranslate"><span class="pre">Stack</span></code> 클래스로 구현하기 위해
리스트를 항목들의 저장 장치로 활용하며,
앞서 소개한 기능들은 모두 메서드로 정의한다.
스택의 탑 역할은 리스트의 오른쪽 끝(마지막 항목)이 수행하도록 한다.
그러면 리스트의 <code class="docutils literal notranslate"><span class="pre">pop()</span></code>와 <code class="docutils literal notranslate"><span class="pre">append()</span></code>를 잘 활용할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;리스트를 활용한 스택 구현&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;새로운 스택 생성&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;스택 표기법: &lt;[1, 2, 3]&gt; 등등&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;비었는지 여부 확인&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;새 항목 추가&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;항목 제거&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;탑 항목 반환&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;항목 개수 반환&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>위 그림을 코드로 구현하면 다음과 같다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_empty</span><span class="p">())</span>
<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">peek</span><span class="p">())</span>
<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_empty</span><span class="p">())</span>
<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mf">8.4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
dog
3
False
8.4
True
2
</pre></div>
</div>
</div>
</div>
<p><strong>참고</strong>: 스택의 탑을 리스트의 첫째 항목으로 정하면 <code class="docutils literal notranslate"><span class="pre">pop(0)</span></code>와 <code class="docutils literal notranslate"><span class="pre">insert(0,</span> <span class="pre">item)</span></code>을 사용해야 한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">==</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>기능면에서는 이전과 완전히 동일하다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>true
</pre></div>
</div>
</div>
</div>
<p>하지만 이전에 보았듯이  <code class="docutils literal notranslate"><span class="pre">pop()</span></code>과 <code class="docutils literal notranslate"><span class="pre">append(item)</span></code>의 시간복잡도는 <span class="math notranslate nohighlight">\(O(1)\)</span>인 반면에
<code class="docutils literal notranslate"><span class="pre">pop(0)</span></code>와 <code class="docutils literal notranslate"><span class="pre">insert(0,</span> <span class="pre">item)</span></code>의 시간복잡도는 <span class="math notranslate nohighlight">\(O(n)\)</span>이라는 점에서 많이 다르다.</p>
<section id="id4">
<h4><span class="section-number">7.1.2.1. </span>확인하기<a class="headerlink" href="#id4" title="Permalink to this headline">#</a></h4>
<p>문제 1. 스택 연산을 아래와 같이 실행한 결과 탑에 위치한 항목은 무엇인가?</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
</pre></div>
</div>
<p>문제 2. 스택 연산을 아래와 같이 실행한 결과 탑에 위치한 항목은 무엇인가?</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="n">m</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
    <span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>문제 3. 주어진 문저열에 포함된 문자를 거꾸로 갖는 문자열을 생성하는 함수 <code class="docutils literal notranslate"><span class="pre">rev_string(my_str)</span></code>를
스택을 이용하여 구현하라.</p>
<p><strong>힌트</strong>: <a class="reference external" href="https://www.youtube.com/watch?v=fZtLSM7k_54&amp;ab_channel=RunestoneInteractive">Stack1</a></p>
</section>
</section>
<section id="id5">
<h3><span class="section-number">7.1.3. </span>실전 예제 1: 괄호 짝맞추기 문제<a class="headerlink" href="#id5" title="Permalink to this headline">#</a></h3>
<p>아래 식에서처럼 함수나 또는 연산 실행을 위해 사용되는 괄호는 짝이 맞아야 한다.
즉, 여는 괄호 하나와 닫는 괄호 하나가 짝이 맞아야 한다.</p>
<div class="math notranslate nohighlight">
\[(5 + 6) * (7 + 8) / (4 + 3)\]</div>
<p>위 표현식에서 괄호만 고려하면 다음 모양이 되어 모든 괄호의 짝이 잘 맞음을 쉽게 확인할 수 있다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>()()()
</pre></div>
</div>
<p>그런데 괄호가 중첩되어 사용되면 보다 복잡해진다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(()()()())

(((())))

(()((())()))
</pre></div>
</div>
<p>예를 들어, 아래 예제는 짝이 맞는 않는 괄호가 존재한다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>((((((())

()))

(()()(()
</pre></div>
</div>
<p>그런데 표현식 또는 코드에 사용된 모든 괄호들의 짝이 맞는가를 확인하는 일은 매우 중요하다.
파이썬의 경우 괄호가 맞지 않으면 실행 전에 바로 구문 오류(<code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>)를 발생시킨다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">7</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span>

<span class="go">File &quot;&lt;ipython-input-14-2a2d38a57b24&gt;&quot;, line 1</span>
<span class="go">    (5 + 6) * (7 + 8) / (4 + 3</span>
<span class="go">                              ^</span>
<span class="go">SyntaxError: unexpected EOF while parsing</span>
</pre></div>
</div>
<p>아래 코드는 스택을 이용하여 괄호로 이루어진 문자열이 짝이 맞는 괄호들로 이루어졌는지 여부를 판단하는
함수를 구현한다.
스택 활용법은 다음과 같다.
괄호로 이루어진 문자열이 주어졌을 때 왼편부터 시작해서 여는 괄호와 닫는 괄호를
만달 때마다 아잭 작업을 반복한다.</p>
<ul class="simple">
<li><p>여는 괄호: 스택에 추가</p></li>
<li><p>닫는 괄호: 스택의 탑 항목 삭제</p></li>
</ul>
<p>위 작업을 반복하다 보면 아래 세 가지 경우가 발생한다.</p>
<ul class="simple">
<li><p>문자열을 다 확인하기 전에 스택이 비워지는 경우: 닫는 괄호가 너무 많음</p></li>
<li><p>끝까지 확인했을 때 스택이 비워지지 않은 경우: 여는 괄호가 너무 많음</p></li>
<li><p>그렇지 않으면 모든 괄호의 짝이 맞음.</p></li>
</ul>
<figure>
<div align="center"><img src="https://runestone.academy/runestone/books/published/pythonds3/_images/simpleparcheck.png" width="40%"></div>
</figure><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">par_checker</span><span class="p">(</span><span class="n">symbol_string</span><span class="p">):</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbol_string</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">par_checker</span><span class="p">(</span><span class="s2">&quot;((()))&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">par_checker</span><span class="p">(</span><span class="s2">&quot;((()()))&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">par_checker</span><span class="p">(</span><span class="s2">&quot;(()&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">par_checker</span><span class="p">(</span><span class="s2">&quot;)(&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
False
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="id6">
<h3><span class="section-number">7.1.4. </span>실전 예제 2: 괄호 짝맞추기 문제(일반화)<a class="headerlink" href="#id6" title="Permalink to this headline">#</a></h3>
<p>소, 중, 대 세 종류의 괄호를 대상으로 짝맞추기 문제를 해결하는 알고리즘을 구현한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(</span></code>, <code class="docutils literal notranslate"><span class="pre">)</span></code>: 튜플, 표현식 등</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>: 사전, 집합 등</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[</span></code>, <code class="docutils literal notranslate"><span class="pre">]</span></code>: 리스트 등</p></li>
</ul>
<p>아래 예제는 모두 괄호들의 짝이 맞는다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{ { ( [ ] [ ] ) } ( ) }

[ [ { { ( ( ) ) } } ] ]

[ ] [ ] [ ] ( ) { }
</pre></div>
</div>
<p>반면 아래의 경우는 서로 다른 종류의 짝이 사용되고 있다.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>( [ ) )

( ( ( ) ] ) )

[ { ( ) ]
</pre></div>
</div>
<p>이전 코드를 조금 수정하면 일반화된 짝맞추기 문제를 해결할 수 있다.
다만, 닫는 괄호를 처리할 때 동일한 종류인지 여부를 추가로 확인해야 한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">balance_checker</span><span class="p">(</span><span class="n">symbol_string</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbol_string</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="s2">&quot;([{&quot;</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">symbol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="n">sym_left</span><span class="p">,</span> <span class="n">sym_right</span><span class="p">):</span>
    <span class="n">all_lefts</span> <span class="o">=</span> <span class="s2">&quot;([{&quot;</span>
    <span class="n">all_rights</span> <span class="o">=</span> <span class="s2">&quot;)]}&quot;</span>
    <span class="k">return</span> <span class="n">all_lefts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sym_left</span><span class="p">)</span> <span class="o">==</span> <span class="n">all_rights</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sym_right</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">balance_checker</span><span class="p">(</span><span class="s1">&#39;{({([][])}())}&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">balance_checker</span><span class="p">(</span><span class="s1">&#39;[{()]&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="id7">
<h3><span class="section-number">7.1.5. </span>실전 예제 3: 이진법 계산<a class="headerlink" href="#id7" title="Permalink to this headline">#</a></h3>
<p>십진법 정수 <span class="math notranslate nohighlight">\(233_{10}\)</span>를 이진법으로 표기하면 <span class="math notranslate nohighlight">\(11101001_{2}\)</span>이 된다.
실제로 두 수가 가리키는 수를 다음과 같으며 동일한 값을 나타낸다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
233_{10} &amp;= 2\times10^{2} + 3\times10^{1} + 3\times10^{0}\\
&amp; \\
11101001_{2} &amp;= 1\times2^{7} + 1\times2^{6} + 1\times2^{5} + 0\times2^{4} + 1\times2^{3} + 0\times2^{2} + 0\times2^{1} + 1\times2^{0}
\end{align*}
\end{split}\]</div>
<p>십진법으로 표기된 정수의 이진법 표기를 찾는 알고리즘은 아래 그림과 같다.</p>
<ul class="simple">
<li><p>2로 나눈 후 나머지를 스택에 추가</p></li>
<li><p>2로 나눈 몫을 대상으로 위 과정 반복</p></li>
<li><p>스택에 쌓인 값들을 거꾸로 읽기. 즉, <code class="docutils literal notranslate"><span class="pre">pop()</span></code>을 연속적으로 활용함.</p></li>
</ul>
<figure>
<div align="center"><img src="https://runestone.academy/runestone/books/published/pythonds3/_images/dectobin.png" width="60%"></div>
</figure><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">divide_by_2</span><span class="p">(</span><span class="n">decimal_num</span><span class="p">):</span>
    <span class="n">rem_stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">decimal_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">decimal_num</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">rem_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span>
        <span class="n">decimal_num</span> <span class="o">=</span> <span class="n">decimal_num</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">bin_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">rem_stack</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
        <span class="n">bin_string</span> <span class="o">=</span> <span class="n">bin_string</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rem_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">bin_string</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">divide_by_2</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">divide_by_2</span><span class="p">(</span><span class="mi">31</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>101010
11111
</pre></div>
</div>
</div>
</div>
</section>
<section id="id8">
<h3><span class="section-number">7.1.6. </span>실전 예제 4: 진법 변환<a class="headerlink" href="#id8" title="Permalink to this headline">#</a></h3>
<p>십진법으로 표기된 정수를 이진법 뿐만 아니라 8진법, 16진법 등으로 자유자재로
변환시키는 함수를 구현해보자.
예를 들어 정수 233을 8진법으로는 <code class="docutils literal notranslate"><span class="pre">351</span></code> 또는 16진법으로는 <code class="docutils literal notranslate"><span class="pre">E9</span></code>이며,
이유는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
233 &amp;= 3\times8^{2} + 5\times8^{1} + 1\times8^{0} \\
&amp;= 14\times16^{1} + 9\times16^{0}
\end{align*}
\end{split}\]</div>
<p>다음 <code class="docutils literal notranslate"><span class="pre">base_converter()</span></code> 함수는 정수 뿐만 아니라 사용될 진법을
결정하는 밑(base)도 함께  인자로 받는다.
밑은 2에서 16 사이의 정수로 가정한다.</p>
<p>알고리즘은 <code class="docutils literal notranslate"><span class="pre">divide_by_2()</span></code> 함수와 거의 동일하다.
다만, 10진법부터 16진법까지는 0부터 9까지의 숫자 이외의 문자를 추가로 사용해야 한다.
여기서는 A, B, C, D, E, F를 10에서 15를 나타내는 기호로 사용한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">push()</span></code> 활용: 이전과 동일</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pop()</span></code> 활용: 10부터 15까지의 나머지에 대해 A부터 F 까지 대신 사용항여 문자열 생성.
이를 위해 <code class="docutils literal notranslate"><span class="pre">digits</span></code> 변수에 할당된 문자열의 인덱싱 활용.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">base_converter</span><span class="p">(</span><span class="n">decimal_num</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    
    <span class="n">digits</span> <span class="o">=</span> <span class="s2">&quot;0123456789ABCDEF&quot;</span>
    
    <span class="n">rem_stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">decimal_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">decimal_num</span> <span class="o">%</span> <span class="n">base</span>
        <span class="n">rem_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span>
        <span class="n">decimal_num</span> <span class="o">=</span> <span class="n">decimal_num</span> <span class="o">//</span> <span class="n">base</span>

    <span class="n">new_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">rem_stack</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
        <span class="n">new_string</span> <span class="o">=</span> <span class="n">new_string</span> <span class="o">+</span> <span class="n">digits</span><span class="p">[</span><span class="n">rem_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>

    <span class="k">return</span> <span class="n">new_string</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">base_converter</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">base_converter</span><span class="p">(</span><span class="mi">623</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">base_converter</span><span class="p">(</span><span class="mi">828375</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11001
1157
CA3D7
</pre></div>
</div>
</div>
</div>
<p><strong>참고</strong></p>
<p>아래 내용은 차후 번역될 예정임.</p>
</section>
</section>
<section id="infix-prefix-and-postfix-expressions">
<h2><span class="section-number">7.2. </span>4.9 Infix, Prefix, and Postfix Expressions<a class="headerlink" href="#infix-prefix-and-postfix-expressions" title="Permalink to this headline">#</a></h2>
<p>When you write an arithmetic expression such as B * C, the form of the
expression provides you with information so that you can interpret it
correctly. In this case we know that the variable B is being multiplied
by the variable C since the multiplication operator * appears between
them in the expression. This type of notation is referred to as
<strong>infix</strong> since the operator is <em>in between</em> the two operands that it is
working on.</p>
<p>Consider another infix example, A + B * C. The operators + and * still
appear between the operands, but there is a problem. Which operands do
they work on? Does the + work on A and B or does the * take B and C?
The expression seems ambiguous.</p>
<p>In fact, you have been reading and writing these types of expressions
for a long time and they do not cause you any problem. The reason for
this is that you know something about the operators + and *. Each
operator has a <strong>precedence</strong> level. Operators of higher precedence are
used before operators of lower precedence. The only thing that can
change that order is the presence of parentheses. The precedence order
for arithmetic operators places multiplication and division above
addition and subtraction. If two operators of equal precedence appear,
then a left-to-right ordering or associativity is used.</p>
<p>Let’s interpret the troublesome expression A + B * C using operator
precedence. B and C are multiplied first, and A is then added to that
result. (A + B) * C would force the addition of A and B to be done
first before the multiplication. In expression A + B + C, by precedence
(via associativity), the leftmost + would be done first.</p>
<p>Although all this may be obvious to you, remember that computers need to
know exactly what operators to perform and in what order. One way to
write an expression that guarantees there will be no confusion with
respect to the order of operations is to create what is called a <strong>fully
parenthesized</strong> expression. This type of expression uses one pair of
parentheses for each operator. The parentheses dictate the order of
operations; there is no ambiguity. There is also no need to remember any
precedence rules.</p>
<p>The expression A + B * C + D can be rewritten as ((A + (B * C)) + D)
to show that the multiplication happens first, followed by the leftmost
addition. A + B + C + D can be written as (((A + B) + C) + D) since the
addition operations associate from left to right.</p>
<p>There are two other very important expression formats that may not seem
obvious to you at first. Consider the infix expression A + B. What would
happen if we moved the operator before the two operands? The resulting
expression would be + A B. Likewise, we could move the operator to the
end. We would get A B +. These look a bit strange.</p>
<p>These changes to the position of the operator with respect to the
operands create two new expression formats, <strong>prefix</strong> and <strong>postfix</strong>.
Prefix expression notation requires that all operators precede the two
operands that they work on. Postfix, on the other hand, requires that
its operators come after the corresponding operands. A few more examples
should help to make this a bit clearer (see :ref:<code class="docutils literal notranslate"><span class="pre">Table</span> <span class="pre">2</span> <span class="pre">&lt;tbl_example1&gt;</span></code>).</p>
<p>A + B * C would be written as + A * B C in prefix. The multiplication
operator comes immediately before the operands B and C, denoting that *
has precedence over +. The addition operator then appears before the A
and the result of the multiplication.</p>
<p>In postfix, the expression would be A B C * +. Again, the order of
operations is preserved since the * appears immediately after the B and
the C, denoting that * has precedence, with + coming after. Although
the operators moved and now appear either before or after their
respective operands, the order of the operands stayed exactly the same
relative to one another.</p>
<p><strong>Table 2: Examples of Infix, Prefix, and Postfix</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>============================ ======================= ========================
        **Infix Expression**   **Prefix Expression**   **Postfix Expression**
============================ ======================= ========================
                       A + B                  \+ A B                    A B +
                  A + B \* C             \+ A \* B C               A B C \* +
============================ ======================= ========================
</pre></div>
</div>
<p>Now consider the infix expression (A + B) * C. Recall that in this
case, infix requires the parentheses to force the performance of the
addition before the multiplication. However, when A + B was written in
prefix, the addition operator was simply moved before the operands, + A
B. The result of this operation becomes the first operand for the
multiplication. The multiplication operator is moved in front of the
entire expression, giving us * + A B C. Likewise, in postfix A B +
forces the addition to happen first. The multiplication can be done to
that result and the remaining operand C. The proper postfix expression
is then A B + C *.</p>
<p>Consider these three expressions again (see :ref:<code class="docutils literal notranslate"><span class="pre">Table</span> <span class="pre">3</span> <span class="pre">&lt;tbl_parexample&gt;</span></code>).
Something very important has happened. Where did the parentheses go? Why
don’t we need them in prefix and postfix? The answer is that the
operators are no longer ambiguous with respect to the operands that they
work on. Only infix notation requires the additional symbols. The order
of operations within prefix and postfix expressions is completely
determined by the position of the operator and nothing else. In many
ways, this makes infix the least desirable notation to use.</p>
<p><strong>Table 3: An Expression with Parentheses</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>============================ ======================= ========================
        **Infix Expression**   **Prefix Expression**   **Postfix Expression**
============================ ======================= ========================
                (A + B) \* C              \* + A B C               A B + C \*
============================ ======================= ========================
</pre></div>
</div>
<p>:ref:<code class="docutils literal notranslate"><span class="pre">Table</span> <span class="pre">4</span> <span class="pre">&lt;tbl_example3&gt;</span></code> shows some additional examples of infix expressions and
the equivalent prefix and postfix expressions. Be sure that you
understand how they are equivalent in terms of the order of the
operations being performed.</p>
<p><strong>Table 4: Additional Examples of Infix, Prefix, and Postfix</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>============================ ======================= ========================
        **Infix Expression**   **Prefix Expression**   **Postfix Expression**
============================ ======================= ========================
              A + B \* C + D        \+ \+ A \* B C D           A B C \* + D +
          (A + B) \* (C + D)          \* + A B + C D           A B + C D + \*
             A \* B + C \* D        \+ \* A B \* C D          A B \* C D \* +
               A + B + C + D          \+ + + A B C D            A B + C + D +
============================ ======================= ========================
</pre></div>
</div>
<section id="conversion-of-infix-expressions-to-prefix-and-postfix">
<h3><span class="section-number">7.2.1. </span>4.9.1 Conversion of Infix Expressions to Prefix and Postfix<a class="headerlink" href="#conversion-of-infix-expressions-to-prefix-and-postfix" title="Permalink to this headline">#</a></h3>
<p>So far, we have used ad hoc methods to convert between infix expressions
and the equivalent prefix and postfix expression notations. As you might
expect, there are algorithmic ways to perform the conversion that allow
any expression of any complexity to be correctly transformed.</p>
<p>The first technique that we will consider uses the notion of a fully
parenthesized expression that was discussed earlier. Recall that A + B
* C can be written as (A + (B * C)) to show explicitly that the
multiplication has precedence over the addition. On closer observation,
however, you can see that each parenthesis pair also denotes the
beginning and the end of an operand pair with the corresponding operator
in the middle.</p>
<p>Look at the right parenthesis in the subexpression (B * C) above. If we
were to move the multiplication symbol to that position and remove the
matching left parenthesis, giving us B C *, we would in effect have
converted the subexpression to postfix notation. If the addition
operator were also moved to its corresponding right parenthesis position
and the matching left parenthesis were removed, the complete postfix
expression would result (see :ref:<code class="docutils literal notranslate"><span class="pre">Figure</span> <span class="pre">6</span> <span class="pre">&lt;fig_moveright&gt;</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. figure:: Figures/moveright.png
   :align: center

   Figure 6: Moving Operators to the Right for Postfix Notation
</pre></div>
</div>
<p>If we do the same thing but instead of moving the symbol to the position
of the right parenthesis, we move it to the left, we get prefix notation
(see :ref:<code class="docutils literal notranslate"><span class="pre">Figure</span> <span class="pre">7</span> <span class="pre">&lt;fig_moveleft&gt;</span></code>). The position of the parenthesis pair is
actually a clue to the final position of the enclosed operator.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. figure:: Figures/moveleft.png
   :align: center

   Figure 7: Moving Operators to the Left for Prefix Notation
</pre></div>
</div>
<p>So in order to convert an expression, no matter how complex, to either
prefix or postfix notation, fully parenthesize the expression using the
order of operations. Then move the enclosed operator to the position of
either the left or the right parenthesis depending on whether you want
prefix or postfix notation.</p>
<p>Here is a more complex expression: (A + B) * C - (D - E) * (F + G).
:ref:<code class="docutils literal notranslate"><span class="pre">Figure</span> <span class="pre">8</span> <span class="pre">&lt;fig_complexmove&gt;</span></code> shows the conversion to postfix and prefix
notations.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. figure:: Figures/complexmove.png
   :align: center

   Figure 8: Converting a Complex Expression to Prefix and Postfix Notations
</pre></div>
</div>
</section>
<section id="general-infix-to-postfix-conversion">
<h3><span class="section-number">7.2.2. </span>4.9.2 General Infix-to-Postfix Conversion<a class="headerlink" href="#general-infix-to-postfix-conversion" title="Permalink to this headline">#</a></h3>
<p>We need to develop an algorithm to convert any infix expression to a
postfix expression. To do this we will look closer at the conversion
process.</p>
<p>Consider once again the expression A + B * C. As shown above,
A B C * + is the postfix equivalent. We have already noted that the
operands A, B, and C stay in their relative positions. It is only the
operators that change position. Let’s look again at the operators in the
infix expression. The first operator that appears from left to right is
+. However, in the postfix expression, + is at the end since the next
operator, *, has precedence over addition. The order of the operators
in the original expression is reversed in the resulting postfix
expression.</p>
<p>As we process the expression, the operators have to be saved somewhere
since their corresponding right operands are not seen yet. Also, the
order of these saved operators may need to be reversed due to their
precedence. This is the case with the addition and the multiplication in
this example. Since the addition operator comes before the
multiplication operator and has lower precedence, it needs to appear
after the multiplication operator is used. Because of this reversal of
order, it makes sense to consider using a stack to keep the operators
until they are needed.</p>
<p>What about (A + B) * C? Recall that A B + C * is the postfix
equivalent. Again, processing this infix expression from left to right,
we see + first. In this case, when we see *, + has already been placed
in the result expression because it has precedence over * by virtue of
the parentheses. We can now start to see how the conversion algorithm
will work. When we see a left parenthesis, we will save it to denote
that another operator of high precedence will be coming. That operator
will need to wait until the corresponding right parenthesis appears to
denote its position (recall the fully parenthesized technique). When
that right parenthesis does appear, the operator can be popped from the
stack.</p>
<p>As we scan the infix expression from left to right, we will use a stack
to keep the operators. This will provide the reversal that we noted in
the first example. The top of the stack will always be the most recently
saved operator. Whenever we read a new operator, we will need to
consider how that operator compares in precedence with the operators, if
any, already on the stack.</p>
<p>Assume the infix expression is a string of tokens delimited by spaces.
The operator tokens are *, /, +, and -, along with the left and right
parentheses, ( and ). The operand tokens are the single-character
identifiers A, B, C, and so on. The following steps will produce a
string of tokens in postfix order.</p>
<ol class="simple">
<li><p>Create an empty stack called <code class="docutils literal notranslate"><span class="pre">op_stack</span></code> for keeping operators.
Create an empty list for output.</p></li>
<li><p>Convert the input infix string to a list by using the string method
<code class="docutils literal notranslate"><span class="pre">split</span></code>.</p></li>
<li><p>Scan the token list from left to right.</p>
<ul class="simple">
<li><p>If the token is an operand, append it to the end of the output
list.</p></li>
<li><p>If the token is a left parenthesis, push it on the <code class="docutils literal notranslate"><span class="pre">op_stack</span></code>.</p></li>
<li><p>If the token is a right parenthesis, pop the <code class="docutils literal notranslate"><span class="pre">op_stack</span></code> until the
corresponding left parenthesis is removed. Append each operator to
the end of the output list.</p></li>
<li><p>If the token is an operator, *, /, +, or -, push it on the
<code class="docutils literal notranslate"><span class="pre">op_stack</span></code>. However, first remove any operators already on the
<code class="docutils literal notranslate"><span class="pre">op_stack</span></code> that have higher or equal precedence and append them
to the output list.</p></li>
</ul>
</li>
<li><p>When the input expression has been completely processed, check the
<code class="docutils literal notranslate"><span class="pre">op_stack</span></code>. Any operators still on the stack can be removed and
appended to the end of the output list.</p></li>
</ol>
<p>:ref:<code class="docutils literal notranslate"><span class="pre">Figure</span> <span class="pre">9</span> <span class="pre">&lt;fig_intopost&gt;</span></code> shows the conversion algorithm working on the
expression A * B + C * D. Note that the first * operator is removed
upon seeing the + operator. Also, + stays on the stack when the second
* occurs, since multiplication has precedence over addition. At the end
of the infix expression the stack is popped twice, removing both
operators and placing + as the last operator in the postfix expression.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. figure:: Figures/intopost.png
   :align: center

   Figure 9: Converting A \* B + C \* D to Postfix Notation
</pre></div>
</div>
<p>In order to code the algorithm in Python, we will use a dictionary
called <code class="docutils literal notranslate"><span class="pre">prec</span></code> to hold the precedence values for the operators. This
dictionary will map each operator to an integer that can be compared
against the precedence levels of other operators (we have arbitrarily
used the integers 3, 2, and 1). The left parenthesis will receive the
lowest value possible. This way any operator that is compared against it
will have higher precedence and will be placed on top of it.
Line 15 defines the operands to be any upper-case character or digit.
The complete conversion function is
shown in :ref:<code class="docutils literal notranslate"><span class="pre">ActiveCode</span> <span class="pre">1</span> <span class="pre">&lt;lst_intopost&gt;</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:caption: Converting Infix Expressions to Postfix Expressions
:nocodelens:
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infix_to_postfix</span><span class="p">(</span><span class="n">infix_expr</span><span class="p">):</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">prec</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">prec</span><span class="p">[</span><span class="s2">&quot;/&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">prec</span><span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">prec</span><span class="p">[</span><span class="s2">&quot;-&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">prec</span><span class="p">[</span><span class="s2">&quot;(&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">op_stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">postfix_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">token_list</span> <span class="o">=</span> <span class="n">infix_expr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">token_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span> <span class="ow">or</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">&quot;0123456789&quot;</span><span class="p">:</span>
            <span class="n">postfix_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
            <span class="n">op_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
            <span class="n">top_token</span> <span class="o">=</span> <span class="n">op_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">top_token</span> <span class="o">!=</span> <span class="s2">&quot;(&quot;</span><span class="p">:</span>
                <span class="n">postfix_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_token</span><span class="p">)</span>
                <span class="n">top_token</span> <span class="o">=</span> <span class="n">op_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">op_stack</span><span class="o">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prec</span><span class="p">[</span><span class="n">op_stack</span><span class="o">.</span><span class="n">peek</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">prec</span><span class="p">[</span><span class="n">token</span><span class="p">]):</span>
                <span class="n">postfix_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="n">op_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">op_stack</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
        <span class="n">postfix_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

    <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">postfix_list</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">infix_to_postfix</span><span class="p">(</span><span class="s2">&quot;A * B + C * D&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">infix_to_postfix</span><span class="p">(</span><span class="s2">&quot;( A + B ) * C - ( D - E ) * ( F + G )&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A B * C D * +
A B + C * D E - F G + * -
</pre></div>
</div>
</div>
</div>
<p>A few more examples of execution in the Python shell are shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">infix_to_postfix</span><span class="p">(</span><span class="s2">&quot;( A + B ) * ( C + D )&quot;</span><span class="p">)</span>
<span class="go">&#39;A B + C D + *&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infix_to_postfix</span><span class="p">(</span><span class="s2">&quot;( A + B ) * C&quot;</span><span class="p">)</span>
<span class="go">&#39;A B + C *&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infix_to_postfix</span><span class="p">(</span><span class="s2">&quot;A + B * C&quot;</span><span class="p">)</span>
<span class="go">&#39;A B C * +&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="postfix-evaluation">
<h3><span class="section-number">7.2.3. </span>4.9.3 Postfix Evaluation<a class="headerlink" href="#postfix-evaluation" title="Permalink to this headline">#</a></h3>
<p>As a final stack example, we will consider the evaluation of an
expression that is already in postfix notation. In this case, a stack is
again the data structure of choice. However, as you scan the postfix
expression, it is the operands that must wait, not the operators as in
the conversion algorithm above. Another way to think about the solution
is that whenever an operator is seen on the input, the two most recent
operands will be used in the evaluation.</p>
<p>To see this in more detail, consider the postfix expression
<code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">5</span> <span class="pre">6</span> <span class="pre">*</span> <span class="pre">+</span></code>. As you scan the expression from left to right, you first
encounter the operands 4 and 5. At this point, you are still unsure what
to do with them until you see the next symbol. Placing each on the stack
ensures that they are available if an operator comes next.</p>
<p>In this case, the next symbol is another operand. So, as before, push it
and check the next symbol. Now we see an operator, *. This means that
the two most recent operands need to be used in a multiplication
operation. By popping the stack twice, we can get the proper operands
and then perform the multiplication (in this case getting the result
30).</p>
<p>We can now handle this result by placing it back on the stack so that it
can be used as an operand for the later operators in the expression.
When the final operator is processed, there will be only one value left
on the stack. Pop and return it as the result of the expression.
:ref:<code class="docutils literal notranslate"><span class="pre">Figure</span> <span class="pre">10</span> <span class="pre">&lt;fig_evalpost1&gt;</span></code> shows the stack contents as this entire example
expression is being processed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. figure:: Figures/evalpostfix1.png
   :align: center

   Figure 10: Stack Contents During Evaluation
</pre></div>
</div>
<p>:ref:<code class="docutils literal notranslate"><span class="pre">Figure</span> <span class="pre">11</span> <span class="pre">&lt;fig_evalpost2&gt;</span></code> shows a slightly more complex example, 7 8 + 3 2</p>
<ul class="simple">
<li><p>/. There are two things to note in this example. First, the stack size
grows, shrinks, and then grows again as the subexpressions are
evaluated. Second, the division operation needs to be handled carefully.
Recall that the operands in the postfix expression are in their original
order since postfix changes only the placement of operators. When the
operands for the division are popped from the stack, they are reversed.
Since division is <em>not</em> a commutative operator, in other words
:math:<code class="docutils literal notranslate"><span class="pre">15/5</span></code> is not the same as :math:<code class="docutils literal notranslate"><span class="pre">5/15</span></code>, we must be sure that
the order of the operands is not switched.</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. figure:: Figures/evalpostfix2.png
   :align: center

   Figure 11: A More Complex Example of Evaluation
</pre></div>
</div>
<p>Assume the postfix expression is a string of tokens delimited by spaces.
The operators are *, /, +, and - and the operands are assumed to be
single-digit integer values. The output will be an integer result.</p>
<ol class="simple">
<li><p>Create an empty stack called <code class="docutils literal notranslate"><span class="pre">operand_stack</span></code>.</p></li>
<li><p>Convert the string to a list by using the string method <code class="docutils literal notranslate"><span class="pre">split</span></code>.</p></li>
<li><p>Scan the token list from left to right.</p>
<ul class="simple">
<li><p>If the token is an operand, convert it from a string to an integer
and push the value onto the <code class="docutils literal notranslate"><span class="pre">operand_stack</span></code>.</p></li>
<li><p>If the token is an operator, *, /, +, or -, it will need two
operands. Pop the <code class="docutils literal notranslate"><span class="pre">operand_stack</span></code> twice. The first pop is the
second operand and the second pop is the first operand. Perform
the arithmetic operation. Push the result back on the
<code class="docutils literal notranslate"><span class="pre">operand_stack</span></code>.</p></li>
</ul>
</li>
<li><p>When the input expression has been completely processed, the result
is on the stack. Pop the <code class="docutils literal notranslate"><span class="pre">operand_stack</span></code> and return the value.</p></li>
</ol>
<p>The complete function for the evaluation of postfix expressions is shown
in :ref:<code class="docutils literal notranslate"><span class="pre">ActiveCode</span> <span class="pre">2</span> <span class="pre">&lt;lst_postfixeval&gt;</span></code>. To assist with the arithmetic, a helper
function <code class="docutils literal notranslate"><span class="pre">do_math</span></code> is defined that will take two operands and an
operator and then perform the proper arithmetic operation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. activecode:: postfixeval
    :caption: Postfix Evaluation
    :nocodelens:
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">postfix_eval</span><span class="p">(</span><span class="n">postfix_expr</span><span class="p">):</span>
    <span class="n">operand_stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">token_list</span> <span class="o">=</span> <span class="n">postfix_expr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">token_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">&quot;0123456789&quot;</span><span class="p">:</span>
            <span class="n">operand_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">operand2</span> <span class="o">=</span> <span class="n">operand_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">operand1</span> <span class="o">=</span> <span class="n">operand_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">do_math</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">operand1</span><span class="p">,</span> <span class="n">operand2</span><span class="p">)</span>
            <span class="n">operand_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">do_math</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span>


<span class="nb">print</span><span class="p">(</span><span class="n">postfix_eval</span><span class="p">(</span><span class="s2">&quot;7 8 + 3 2 + /&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.0
</pre></div>
</div>
</div>
</div>
<p>It is important to note that in both the postfix conversion and the
postfix evaluation programs we assumed that there were no errors in the
input expression. Using these programs as a starting point, you can
easily see how error detection and reporting can be included. We leave
this as an exercise at the end of the chapter.</p>
<p><strong>Self Check</strong></p>
<p>Q-3: Without using the activecode <code class="docutils literal notranslate"><span class="pre">infix_to_postfix</span></code> function, convert the following expression to postfix  <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span> <span class="pre">/</span> <span class="pre">(16</span> <span class="pre">-</span> <span class="pre">4)</span></code>.</p>
<p>Q-4: What is the result of evaluating the following: <code class="docutils literal notranslate"><span class="pre">17</span> <span class="pre">10</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">9</span> <span class="pre">/</span> <span class="pre">==</span></code> ?</p>
<p>정답: 9</p>
<p>Q-5: Modify the <code class="docutils literal notranslate"><span class="pre">infix_to_postfix</span></code> function so that it can convert the following expression:  <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">**</span> <span class="pre">(4</span> <span class="pre">-</span> <span class="pre">2)</span></code>. Run the function on the expression and paste the answer here</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. youtube:: LO-2q4pSsdM
    :divid: video_Stack3
    :height: 315
    :width: 560
    :align: left
</pre></div>
</div>
</section>
<section id="discussion-questions">
<h3><span class="section-number">7.2.4. </span>Discussion Questions<a class="headerlink" href="#discussion-questions" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>Convert the following infix expressions to prefix (use full
parentheses):</p>
<ul class="simple">
<li><p>(A+B)*(C+D)*(E+F)</p></li>
<li><p>A+((B+C)*(D+E))</p></li>
<li><p>A*B*C*D+E+F</p></li>
</ul>
</li>
<li><p>Convert the above infix expressions to postfix (use full
parentheses).</p></li>
<li><p>Convert the above infix expressions to postfix using the direct
conversion algorithm. Show the stack as the conversion takes place.</p></li>
<li><p>Evaluate the following postfix expressions. Show the stack as each
operand and operator is processed.</p>
<ul class="simple">
<li><p>2 3 * 4 +</p></li>
<li><p>1 2 + 3 + 4 + 5 +</p></li>
<li><p>1 2 3 4 5 * + * +</p></li>
</ul>
</li>
</ol>
</section>
<section id="id9">
<h3><span class="section-number">7.2.5. </span>프로그래밍 실습 문제<a class="headerlink" href="#id9" title="Permalink to this headline">#</a></h3>
<section id="id10">
<h4><span class="section-number">7.2.5.1. </span>괄호 짝맞추기<a class="headerlink" href="#id10" title="Permalink to this headline">#</a></h4>
<ol>
<li><p>HTML 문서에 사용되는 태그(tag)는 아래 예제에서처럼 여는 형식과 닫는 형식의 짝이 맞아야 한다.</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
     <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>
        문제해결 알고리즘
     <span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
     <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>스택 자료형<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>HTML 문서를 대상으로 태그 짝맞추기 여부를 판별하는 함수를 구현하라.</p>
</li>
</ol>
</section>
<section id="id11">
<h4><span class="section-number">7.2.5.2. </span>전위, 중위, 후위 표기법<a class="headerlink" href="#id11" title="Permalink to this headline">#</a></h4>
<ol class="simple">
<li><p>Modify the infix-to-postfix algorithm so that it can handle errors.</p></li>
<li><p>Modify the postfix evaluation algorithm so that it can handle errors.</p></li>
<li><p>Implement a direct infix evaluator that combines the functionality of
infix-to-postfix conversion and the postfix evaluation algorithm.
Your evaluator should process infix tokens from left to right and use
two stacks, one for operators and one for operands, to perform the
evaluation.</p></li>
<li><p>Turn your direct infix evaluator from the previous problem into a
calculator.</p></li>
</ol>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="python_list_dict.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">6. </span>알고리즘 분석 2부: 파이썬 모음 자료형 분석</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="queues.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8. </span>기초 추상 자료형 구현 2부: 큐</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By 코딩알지<br/>
  
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>