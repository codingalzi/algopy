

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>22. 되추적 기법 &#8212; 문제해결 알고리즘</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'backtracking';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="23. 제네릭 프로그래밍" href="generic_programming.html" />
    <link rel="prev" title="21. 탐욕 기법 대 동적계획법" href="greedy_algorithm_3.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    <p class="title logo__title">문제해결 알고리즘</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">파이썬 클래스와 추상 자료형</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="oop-classes-objects.html">1. 클래스, 인스턴스, 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="oop-inheritance.html">2. 상속</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">선형 자료 구조</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="queues.html">3. 큐(Queue)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks.html">4. 스택(Stack)</a></li>
<li class="toctree-l1"><a class="reference internal" href="deques.html">5. 덱(Deque)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">알고리즘 시간 복잡도</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="time_complexity.html">6. 시간 복잡도</a></li>
<li class="toctree-l1"><a class="reference internal" href="orders.html">7. 차수</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_list_dict.html">8. 파이썬 모음 자료형 분석</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">재귀</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="recursive_functions_1.html">9. 재귀 함수</a></li>
<li class="toctree-l1"><a class="reference internal" href="recursive_functions_2.html">10. 재귀 시각화</a></li>
<li class="toctree-l1"><a class="reference internal" href="hanoi_tower.html">11. 하노이의 탑과 미로게임</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">탐색과 정렬</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="sort_search_1.html">12. 탐색과 분할 정복</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort_search_2.html">13. 버블/선택/합병/퀵 정렬</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">트리, 힙, 맵</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_1.html">14. 트리(Tree)</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_2.html">15. 힙(Heap)</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_3.html">16. 맵(Map)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">동적계획법</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="dynamic_programming_1.html">17. 최적화 문제와 동적계획법</a></li>
<li class="toctree-l1"><a class="reference internal" href="dynamic_programming_2.html">18. 플로이드-워셜 알고리즘</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">탐욕 기법</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_1.html">19. 최소비용 신장트리</a></li>
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_2.html">20. 다익스트라 알고리즘</a></li>
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_3.html">21. 탐욕 기법 대 동적계획법</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">되추적 기법과 제네릭 프로그래밍</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">22. 되추적 기법</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic_programming.html">23. 제네릭 프로그래밍</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NP 이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="p_np.html">24. P-NP 문제</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/codingalzi/algopy/blob/master/jupyter-book/backtracking.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/codingalzi/algopy" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/codingalzi/algopy/issues/new?title=Issue%20on%20page%20%2Fbacktracking.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/backtracking.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>되추적 기법</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">22.1. 제약 충족 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">22.2. 되추적 기법</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#n">22.3. n-여왕말 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#m-4">22.4. m-색칠 문제와 4색 정리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#m">22.4.1. m-색칠 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">22.4.2. 4색 정리</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">22.5. 연습문제</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="sec-backtracking">
<span id="id1"></span><h1><span class="section-number">22. </span>되추적 기법<a class="headerlink" href="#sec-backtracking" title="Permalink to this heading">#</a></h1>
<p><strong>슬라이드</strong></p>
<p>본문 내용을 요약한 <a class="reference external" href="https://github.com/codingalzi/algopy/raw/master/slides/slides-backtracking.pdf">슬라이드</a>를 다운로드할 수 있다.</p>
<p><strong>주요 내용</strong></p>
<ul class="simple">
<li><p>제약 충족 문제</p></li>
<li><p>되추적 기법</p></li>
<li><p>n-여왕말 문제</p></li>
<li><p>그래프 색칠하기</p></li>
</ul>
<section id="id2">
<h2><span class="section-number">22.1. </span>제약 충족 문제<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<p>제약 충족 문제<font size='2'>constraint-satisfaction problem</font>(CSP)는
여러 개의 대상 각각에 할당할 값을 특정 도메인(영역)에서 정해진 제약 조건에 따라 선택하는 문제이다.</p>
<p>예를 들어 4-여왕말 문제가 대표적인 제약 충족 문제이다.
여기서 여왕말은 체스판에서 상하좌우, 대각선 등 임의로 움직일 수 있다.
4-여왕말 문제는 1번, 2번, 3번, 4번으로 구분되는 네 개의 여왕말을
<code class="docutils literal notranslate"><span class="pre">4x4</span></code> 모양의 체스판에서 서로 잡히지 않도록 위치시키는 문제이다.
4-여왕말 문제를 정형화하면 다음과 같다.
대상 여왕말 각각은 변수로 표현된다.</p>
<ul class="simple">
<li><p>변수: 1번부터 4번까지 이름이 붙은 네 개의 여왕말</p></li>
<li><p>도메인: <code class="docutils literal notranslate"><span class="pre">4x4</span></code> 모양의 체스판에 포함된 1번 열부터 4번 열</p></li>
<li><p>제약 조건: 서로 다른 두 개의 여왕말이 하나의 행, 열, 또는 대각선 상에 위치하지 않음</p></li>
</ul>
<p>아래 그림은 4개의 여왕말이 앞서 언급된 제약 조건을 만족시키거나 못하는 경우를 함께 보여준다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-01a.png" width="150"/></div></p></section>
<section id="id3">
<h2><span class="section-number">22.2. </span>되추적 기법<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h2>
<p>되추적 기법은 제약 충족 문제를 해결하는 기법이며
백트래킹<font size='2'>backtracking</font>으로 불리기도 한다.
많은 제약 충족 문제가 제약 조건만 서로 다를 뿐 동일한 되추적 알고리즘으로 해결되기도 한다.
여기서는 두 개의 문제를 이용하여 되추적 기법의 활용법을 설명한다.</p>
<p>되추적 기법 이해에 필요한 개념은 다음과 같다.</p>
<ul class="simple">
<li><p>깊이 우선 탐색</p></li>
<li><p>상태 공간 트리</p></li>
<li><p>노드의 유망성</p></li>
<li><p>가지치기</p></li>
</ul>
<p><strong>깊이 우선 탐색</strong></p>
<p>깊이 우선 탐색<font size='2'>depth-first-search</font>(DFS)은 (루트 지정) 트리(rooted tree)를 대상으로 하는
모든 가능성을 탐색하는 일종의 완전 탐색<font size='2'>brute force</font>기법이다.
깊이 우선 탐색은 트리에 포함된 모든 노드를 아래 과정을 이용하여 탐색한다.</p>
<ul class="simple">
<li><p>루트 노드에서 시작해서 갈 수 있는 한 가장 왼쪽 자식 노드로 탐색 진행</p></li>
<li><p>잎 노드에 다달한 경우 탐색 대상이 될 수 있는 자식 노드를 갖는 가장 가까운 조상 노드로 이동해서 깊이 우선 탐색 진행.
단, 한 번 탐색한 자식 노드는 무시.</p></li>
</ul>
<p>위 과정을 실행하다가 더 이상 탐색 대상이 되는 노드가 존재하지 않는 경우 탐색을 중지한다.
아래 그림은 루트 노드에서 시작하여 깊이 우선 탐색의 대상이 되는 노드들의 순서를 보여준다.</p>
<p><p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-02.png" width="400"/></div></p></p><p><strong>상태 공간 트리</strong></p>
<p>상태 공간 트리<font size='2'>state space tree</font>는
(대상) 변수가 가질 수 있는 모든 값으로 구성된 트리이다.
아래에 보여지는 트리는 <code class="docutils literal notranslate"><span class="pre">4x4</span></code>로 이루어진 체스판에 네 개의 체스 여왕말을 놓을 수 있는 위치를
노드로 표현한 상태 공간 트리이다.</p>
<ul class="simple">
<li><p>루트: 출발 노드이며 여왕말의 위치와는 무관함.</p></li>
<li><p>깊이 <span class="math notranslate nohighlight">\(k\)</span>의 노드: <span class="math notranslate nohighlight">\(k\)</span> 번째 여왕말이 놓일 수 있는 열 위치</p></li>
</ul>
<p>여기서 <strong>깊이</strong>는 노드가 루트로부터의 경로의 길이를 가리킨다.</p>
<p><p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-03.png" width="500"/></div></p></p><p><strong>노드의 유망성</strong></p>
<p>노드가 지정된 제약 조건을 만족시키는 경우 <strong>유망하다</strong><font size='2'>promissing</font>고 말한다.
예를 들어, 아래 그림에서
첫째 여왕말의 위치에 따라 둘째 여왕말이 놓일 수 있는 위치에 해당하는 노드의 유망성이 결정된다.
둘째 여왕말에 대해 1번, 2번 칸에 해당하는 노드는 유망하지 않다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-04.png" width="300"/></div></p><p><strong>가지치기</strong></p>
<p>가지치기<font size='2'>pruning</font>특정 노드에서 시작되는 가지를 제거하는 과정을 가리킨다.
아래 그림은 <code class="docutils literal notranslate"><span class="pre">4x4</span></code>로 이루어진 체스판에 네 개의 여왕말을 놓을 수 있는 위치를
노드로 표현한 상태 공간 트리에서 유망하지 않은 노드를 가지치기한 결과를 보여준다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-05.png" width="600"/></div></p><p><strong>4-여왕말 문제 되추적 알고리즘</strong></p>
<p>4 개의 여왕말을 서로 공격하지 못하도록 위치시키는 4-여왕말 문제를 해결하는 되추적 알고리즘은
상태 공간 트리를 대상으로 깊이 우선 탐색, 노드의 유망성 판단, 가지치기를
아래 과정에 따라 반복 실행한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">4x4</span></code>로 이루어진 체스판에 네 개의 체스 여왕말을 놓을 수 있는 위치를 노드로 표현한 상태 공간 트리의
루트에서부터 깊이 우선 탐색 실행</p></li>
<li><p>탐색 과정에서 유망하지 않은 노드를 만나면 가지치기 실행 후 깊이 우선 탐색 대상이 될 수 있는 자식 노드를
갖는 조상 노드로 되돌아가서, 즉 되추적하여 그곳에서부터 깊이 우선 탐색 실행.
단, 이미 탐색한 자식 노드는 제외</p></li>
<li><p>탐색이 더 이상 진행할 수 없는 경우 알고리즘 종료</p></li>
</ul>
<p>아래 그림은 4-여왕말 문제에 대해 되추적 알고리즘을 적용하는 과정을 보여준다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-06.png" width="600"/></div></p><p>유망하지 않은 노드에서 가지치기를 하는 되추적 알고리즘은
그렇지 않은 일반 깊이 우선 탐색에 비해 훨씬 적은 수의 노드를 대상으로 탐색한다.
예를 들어 4-여왕말 문제를 일반 깊이 우선 탐색으로 해결하고자 할 경우 155 개의 노드를
탐색해야 하지만 되추적 알고리즘을 적용하면 27개의 노드만 탐색하면 된다.</p>
</section>
<section id="n">
<h2><span class="section-number">22.3. </span>n-여왕말 문제<a class="headerlink" href="#n" title="Permalink to this heading">#</a></h2>
<p>4-여왕말 문제를 일반화한 n-여왕말 문제를 해결하는 되추적 알고리즘 구현한다.
n-여왕말 문제를 정의하는 변수, 도메인, 제약 조건은 다음과 같다.</p>
<ul class="simple">
<li><p>(대상) 변수: 1번부터 n번까지 이름이 붙은 n 개의 여왕말</p></li>
<li><p>도메인: <code class="docutils literal notranslate"><span class="pre">nxn</span></code> 모양의 체스판에 포함된 1번부터 n번 열</p></li>
<li><p>제약 조건: 서로 다른 두 개의 여왕말이 하나의 행, 열, 또는 대각선 상에 위치하지 않음</p></li>
</ul>
<p>예를 들어 8-여왕말 문제를 정의하는 변수와 도메인은 다음과 같다.
8개의 여왕말 모두 1열부터 8열 어딘가에 위치할 수 있다.
단, 그 중에서 제약 조건을 만족하는 열을 찾아야 한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="c1"># 변수: 네 개의 여왕말의 번호, 즉, 1, 2, ..., 8</span>
<span class="n">variables</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

<span class="c1"># 도메인: 각각의 여왕말이 자리잡을 수 있는 가능한 모든 열의 위치. </span>
<span class="n">domains</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="n">columns</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
    <span class="n">domains</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">columns</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">domains</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(list,
            {1: range(1, 9),
             2: range(1, 9),
             3: range(1, 9),
             4: range(1, 9),
             5: range(1, 9),
             6: range(1, 9),
             7: range(1, 9),
             8: range(1, 9)})
</pre></div>
</div>
</div>
</div>
<p><strong>유망성 판단</strong></p>
<p>되추적 기법을 이용하여 1번 여왕말부터 차례대로 위치시킬 것이다.
따라서 여왕말을 특정 열에 위치시킬 때마다 그때까지 자리가 정해진
여왕말들과의 제약 조건이 성립함을 보여야 한다.
즉, 새로운 여왕말을 위치시킬 때마다 해당 여왕말의 유망성을 확인해야 한다.</p>
<p>이를 위해 되추적 기법이 진행되는 동안 자리를 잡은 여왕말들의 정보를 저정해야 한다.
여기서는 여왕말 번호와 해당 여왕말의 위치한 열의 번호를 각각 키와 값으로 사용하는 사전을 이용한다.
예를 들어 4번 여왕말까지 위치시킨 경우 아래 <code class="docutils literal notranslate"><span class="pre">assignment</span></code> 변수가 가리키는 사전에
네 개의 여왕말의 위치 정보가 담겨 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">assignment</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
              <span class="mi">3</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">}</span>
</pre></div>
</div>
<p>위치가 이미 정해진 여왕말들을 대상으로 다음 세 개의 제약 조건이 성립함을 확인한다.</p>
<ul>
<li><p>동일한 행에 위치하지 않기: 각각의 여왕말이 다른 행에 위치되도록 하기에 알고리즘이 작동하기에 자연스럽게 처리됨.</p></li>
<li><p>동일한 열에 위치하지 않기: 서로 다른 키에 대해 동일한 값이 사용되지 않도록 해야 함.</p></li>
<li><p>동일한 대각선 상에 위치하지 않기:
두 개의 여왕말 <code class="docutils literal notranslate"><span class="pre">q1</span></code>, <code class="docutils literal notranslate"><span class="pre">q2</span></code>가 동일한 대각선 상에 위치하려면 행과 열의 차이의 절댓값이 같아야 함(아래 그림 참고.
아래 식에서 예를 들어 <code class="docutils literal notranslate"><span class="pre">q1r</span></code>과 <code class="docutils literal notranslate"><span class="pre">q1c</span></code>는 각각 <code class="docutils literal notranslate"><span class="pre">q1</span></code>이 위치한 행과 열의 좌표를 가리킴.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">abs</span><span class="p">(</span><span class="n">q1r</span> <span class="o">-</span> <span class="n">q2r</span><span class="p">)</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="n">q1c</span> <span class="o">-</span> <span class="n">q2c</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-07.png" width="300"/></div></p><p>아래 <code class="docutils literal notranslate"><span class="pre">promissing_queens()</span></code> 함수가 이미 자리를 차지한 여왕말들을 대상으로 세 개의 제약 조건이
만족하는지 여부를 확인한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">promissing_queens</span><span class="p">(</span><span class="n">assignment</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>

    <span class="c1"># q1: 모든 여왕말 대상으로 유망성 확인</span>
    <span class="k">for</span> <span class="n">q1r</span><span class="p">,</span> <span class="n">q1c</span> <span class="ow">in</span> <span class="n">assignment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1"># q1의 행과 열</span>

        <span class="c1"># q2 = 아랫쪽에 자리한 여왕말들과 함께 제약 조건 성립 여부 확인</span>
        <span class="c1"># q1r과 q2r은 자연스럽게 다름</span>
        <span class="k">for</span> <span class="n">q2r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q1r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> 
            <span class="n">q2c</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[</span><span class="n">q2r</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">q1c</span> <span class="o">==</span> <span class="n">q2c</span><span class="p">:</span>                       <span class="c1"># 동일 열에 위치?</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">q1r</span> <span class="o">-</span> <span class="n">q2r</span><span class="p">)</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="n">q1c</span> <span class="o">-</span> <span class="n">q2c</span><span class="p">):</span> <span class="c1"># 동일 대각선상에 위치?</span>
                <span class="k">return</span> <span class="kc">False</span> 

    <span class="c1"># 모든 변수에 대해 제약조건 만족됨</span>
    <span class="k">return</span> <span class="kc">True</span> 
</pre></div>
</div>
</div>
</div>
<p><strong>되추적 함수 구현</strong></p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">backtracking_search_queens()</span></code> 함수는 n-여왕말 문제를 되추적 기법으로 해결한다.
함수 정의에 사용된 변수들의 기능은 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_queens</span></code>: 여왕말의 개수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variables</span></code>: 여왕말 번호</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">domains</span></code>: 각 여왕말의 도메인(영역). 여기서는 모두 1부터 <code class="docutils literal notranslate"><span class="pre">num_queens</span></code> 까지의 번호 사용.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assignment</span></code> 매개변수: 되추적 과정에서 이미 자리를 차지한 여왕말들의 위치 정보를 담은 사전 객체</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unassigned</span></code>: 아직까지 자리를 잡지 못한 여왕말들의 번호로 구성된 리스트</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">first</span></code>: <code class="docutils literal notranslate"><span class="pre">unassigned</span></code> 에 포함된 여왕말 중에서 가장 낮은 번호의 여왕말. 즉, 이제 위치시켜야할 여왕말 번호.</p></li>
</ul>
<p>함수 본체에 사용되는 <code class="docutils literal notranslate"><span class="pre">for</span></code> 반복문은
새로운 여왕말을 위치시키기 위해 모든 열을 대상으로 되추적 기법을
아래와 같이 적용한다.</p>
<ul class="simple">
<li><p>유망성이 확인되면 되추적 기법을 재귀적으로 적용</p></li>
<li><p>유망성이 확인되지 않으면 바로 재귀 적용 중지 후 가장 가까운 조상 노드의 형제 노드로 이동하여 되추적 기법 재귀 적용</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">backtracking_search_queens</span><span class="p">(</span><span class="n">num_queens</span><span class="p">,</span> <span class="n">assignment</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
    
    <span class="c1"># 변수</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_queens</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># 도메인: 각각의 여왕말이 위치할 수 있는 칸</span>
    <span class="n">domains</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_queens</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
        <span class="n">domains</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">columns</span>
    
    <span class="c1"># 재귀 종료 조건: 모든 변수에 대한 값이 지정된 경우</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">assignment</span>
    
    <span class="c1"># 재귀 실행: 아직 자리 잡지 못한 여왕말이 존재하는 경우</span>
    <span class="n">unassigned</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assignment</span><span class="p">]</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">unassigned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># 다음 대상 여왕말</span>
    
    <span class="c1"># first 여왕말 위치시키기. 재귀 적용</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">[</span><span class="n">first</span><span class="p">]:</span>
        <span class="c1"># 기존의 assignment를 보호하기 위해 복사본을 활용함.</span>
        <span class="c1"># 되추적이 발생할 때 이전 할당값을 기억해 두기 위해서임.</span>
        <span class="n">local_assignment</span> <span class="o">=</span> <span class="n">assignment</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_assignment</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># local_assignment 값이 유망하면 되추적 기법 재귀 적용</span>
        <span class="c1"># 즉, 다음 여왕말 대상으로 되추적 기법 적용</span>
        <span class="k">if</span> <span class="n">promissing_queens</span><span class="p">(</span><span class="n">local_assignment</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">backtracking_search_queens</span><span class="p">(</span><span class="n">num_queens</span><span class="p">,</span> <span class="n">local_assignment</span><span class="p">)</span>

            <span class="c1"># 모든 여왕말을 위치시켰을 때 여왕말들의 정보 반환</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 유망성 확인에 실패한 경우 재귀 종료. 즉 가지치기 실행.</span>
    <span class="k">return</span> <span class="kc">None</span>    
</pre></div>
</div>
</div>
</div>
<p>4-여왕말 문제와 8-여왕말 문제의 해결책은 다음과 같다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backtracking_search_queens</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(int, {1: 2, 2: 4, 3: 1, 4: 3})
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backtracking_search_queens</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(int, {1: 1, 2: 5, 3: 8, 4: 6, 5: 3, 6: 7, 7: 2, 8: 4})
</pre></div>
</div>
</div>
</div>
<p><strong>n-여왕말 문제 되추적 알고리즘의 시간 복잡도</strong></p>
<p>n 개의 여왕말이 주어졌을 때 상태 공간 트리에 포함된 노드의 수는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
1 + n + n^2 + n^3 + \cdots + n^n = \frac{n^{n+1}-1}{n-1}
\]</div>
<p>따라서 되추적 알고리즘이 탐색해야 하는 노드 수는 경우마다 다를 수 있지만
최대 n의 지수승 만큼 많은 수의 노드를 탐색해야 할 수도 있다.
하지만 이보다 더 효율적인 알고리즘은 아직 알려지지 않았다.</p>
</section>
<section id="m-4">
<h2><span class="section-number">22.4. </span>m-색칠 문제와 4색 정리<a class="headerlink" href="#m-4" title="Permalink to this heading">#</a></h2>
<section id="m">
<h3><span class="section-number">22.4.1. </span>m-색칠 문제<a class="headerlink" href="#m" title="Permalink to this heading">#</a></h3>
<p>m-색칠<font size='2'>m-coloring</font> 문제는
최대 m 개의 색<font size='2'>color</font>을 이용하여
<strong>무방향 그래프의 서로 인접한 노드가 서로 다른 색을 갖는다</strong>는
색칠 조건이 만족되도록 색칠하는 문제이다.
예를 들어 아래 무방향 그래프에 대해서는
최소 세 종류의 색을 사용해야 색칠 조건이 만족될 수 있음을 보여준다.</p>
<p>
<table class="field">
  <tr>
    <td style="padding:0 50px 0 50px;">
      <div><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-08c.png" width="200"/></div>
    </td>
    <td style="padding:0 50px 0 50px;">
      <div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-08d.png" width="200"/></div>
      </td>
  </tr>
</table>
</p><p>m-색칠 문제는 지도를 색칠할 때 유용하게 활용된다.
이유는 지도와 지도를 평면 그래프로 서로 일대일 대응되기 때문이다.</p>
<p><div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Four_Colour_Map_Example.svg/1920px-Four_Colour_Map_Example.svg.png" width="300"/></div></p>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://ko.wikipedia.org/wiki/4색정리">위키피디아: 4색정리</a>&gt;</div></p><p>평면 그래프는 서로 교차하는 간선이 없는 무방향 그래프이다.
예를 들어 아래 왼쪽 지도와 오른쪽 평면 그래프는 서로 일대일 대응된다.</p>
<ul class="simple">
<li><p>노드: 지도에 사용된 국가, 지역 등의 영역</p></li>
<li><p>간선: 서로 인접한 두 영역 연결</p></li>
</ul>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-09a.png" width="400"/></div></p><p>m-색칠 문제를 알고리즘을 되추적 기법으로 해결할 수 있다.
설명을 위해 먼저 앞서 언급한 그래프를 대상으로 3-색칠 문제에 되추적 기법을 적용하는 과정을 살펴 본다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-08d.png" width="200"/></div></p><p>아래 그래프는 깊이 우선 탐색에 노드의 유망성과 가지치기를 적용한 결과를 보여준다.
단, 1, 2, 3은 각각 빨강, 파랑, 갈색을 가리킨다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-11.png" width="400"/></div></p><p>m-색칠 문제를 해결하는 되추적 알고리즘 구현하려 하기 위해
먼저 m-색칠 문제를 정의하는 변수, 도메인, 제약 조건을 확인하면 다음과 같다.</p>
<ul class="simple">
<li><p>(대상) 변수: 1번부터 n번까지 이름이 붙은 n 개의 노드</p></li>
<li><p>도메인: 1번부터 m번까지 이름이 붙은 m 종류의 색</p></li>
<li><p>제약 조건: 간선으로 연결된 이웃 노드는 서로 다른 색을 가져야 함.</p></li>
</ul>
<p>예를 들어 4 개의 노드로 구성된 평면 그래프에 대한 3-색 문제를 정의하는 변수와 도메인은 다음과 같다.
각각의 노드에 동일하게 빨강(1), 파랑(2), 갈색(3) 어느 색도 취할 수 있다.
단, 제약 조건을 만족시켜야 한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="c1"># 변수: 네 노드의 번호, 즉, 1, 2, 3, 4</span>
<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="c1"># 도메인: 각각의 노드에 칠할 수 있는 가능한 모든 색상</span>
<span class="c1"># 3-색칠하기: 1(빨강), 2(파랑), 3(갈색)</span>
<span class="n">domains</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
    <span class="n">domains</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">domains</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(list, {1: [1, 2, 3], 2: [1, 2, 3], 3: [1, 2, 3], 4: [1, 2, 3]})
</pre></div>
</div>
</div>
</div>
<p><strong>유망성 판단</strong></p>
<p>새로운 노드의 색을 지정할 때 두 해당 노드와 간선으로 연결된 노드들의 색상을 확인해야 한다.
따라서 노드의 유망성을 확인할 때 간선에 대한 정보와 그때까지 색칠해진 노드의 색 정보를
알아야 한다.</p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">promissing_colors()</span></code> 함수는
평면 그래프의 간선 정보가 주어졌을 때
새로운 노드에 할당된 색이 기존에 지정된 노드들의 색과 함께
제약 조건을 만족시키는지 여부를 판단한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">variable</span></code>: 새롭게 색이 할당된 노드</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constraints</span></code>: 평면 그래프의 간선 정보를 담은 사전</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assigment</span></code>: 되추적 기법 적용 기간동안 색이 할당된 노드들의 정보를 담은 사전</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">promissing_colors</span><span class="p">(</span><span class="n">variable</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">assignment</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;새로운 노드인 variable에 색을 할당할 때 </span>
<span class="sd">    간선으로 연결된 이웃 노드와의 색이 달라야 한다는</span>
<span class="sd">    제약조건을 assignment가 만족하는지 여부 확인</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">[</span><span class="n">variable</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var</span> <span class="ow">in</span> <span class="n">assignment</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">assignment</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">==</span> <span class="n">assignment</span><span class="p">[</span><span class="n">variable</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="k">def</span> <span class="nf">promissing_colors</span><span class="p">(</span><span class="n">variable</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">assignment</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span><span class="w">     </span><span class="sd">&quot;&quot;&quot;새로운 노드인 variable에 색을 할당할 때 </span>
<span class="g g-Whitespace">      </span><span class="mi">3</span><span class="sd">     간선으로 연결된 이웃 노드와의 색이 달라야 한다는</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span><span class="sd">     제약조건을 assignment가 만족하는지 여부 확인</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span><span class="sd">     &quot;&quot;&quot;</span>
<span class="g g-Whitespace">      </span><span class="mi">7</span>     <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">[</span><span class="n">variable</span><span class="p">]:</span>

<span class="ne">NameError</span>: name &#39;defaultdict&#39; is not defined
</pre></div>
</div>
</div>
</div>
<p>예를 들어 아래 평면 그래프의 간선 정보는 다음과 같다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-08c.png" width="200"/></div></p><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 각 노드에 대한 이웃 노드의 리스트</span>
<span class="n">constraints</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span> <span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="mi">2</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="mi">3</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="mi">4</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p><strong>되추적 함수 구현</strong></p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">backtracking_search_colors()</span></code> 함수는 m-색칠 문제를 되추적 기법으로 해결한다.
함수 정의에 사용된 변수들의 기능은 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_nodes</span></code>: 노드의 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_colors</span></code>: 사용 가능한 색의 수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constraints</span></code>: 평면 그래프의 간선 정보를 담은 사전</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assigment</span></code>: 되추적 기법 적용 기간동안 색이 할당된 노드들의 정보를 담은 사전</p></li>
</ul>
<p>함수 본체에 사용되는 <code class="docutils literal notranslate"><span class="pre">for</span></code> 반복문은
새로운 노드의 색을 지정하기 위해 사용 가능한 모든 색을 대상으로 되추적 기법을 아래와 같이 적용한다.</p>
<ul class="simple">
<li><p>유망성이 확인되면 되추적 기법을 재귀적으로 적용</p></li>
<li><p>유망성이 확인되지 않으면 바로 재귀 적용 중지 후 가장 가까운 조상 노드의
형제 노드로 이동하여 되추적 기법 재귀 적용</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">backtracking_search_colors</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_colors</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">assignment</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;assignment: 각각의 변수를 키로 사용하고 키값은 해당 변수에 할당될 값&quot;&quot;&quot;</span>

    <span class="c1"># 변수</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_nodes</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 도메인: 각각의 노드에 칠할 수 있는 가능한 모든 색상</span>
    <span class="n">domains</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_colors</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
        <span class="n">domains</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span>
        
    <span class="c1"># 재귀 종료 조건: 모든 변수에 대한 값이 지정된 경우</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">assignment</span>
    
    <span class="c1"># 재귀 실행: 아직 색이 지정되지 않은 노드가 존재하는 경우</span>
    <span class="n">unassigned</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assignment</span><span class="p">]</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">unassigned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># 다음 대상 노드</span>
    
    <span class="c1"># first 노드 색칠하기. 재귀 적용</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">domains</span><span class="p">[</span><span class="n">first</span><span class="p">]:</span>
        <span class="c1"># 주의: 기존의 assignment를 보호하기 위해 복사본 활용</span>
        <span class="c1"># 되추적이 발생할 때 이전 할당값을 기억해 두기 위해서임.</span>
        <span class="n">local_assignment</span> <span class="o">=</span> <span class="n">assignment</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_assignment</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        
        <span class="c1"># local_assignment 값이 유망하면 재귀 호출을 사용하여 변수 할당 이어감.</span>
        <span class="k">if</span> <span class="n">promissing_colors</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">local_assignment</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">backtracking_search_colors</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_colors</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">local_assignment</span><span class="p">)</span>

            <span class="c1"># 모든 노드의 색이 지정되었을 때 해당 정보 반환</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># 유망성 확인에 실패한 경우 재귀 종료. 즉 가지치기 실행.</span>
    <span class="k">return</span> <span class="kc">None</span>    
</pre></div>
</div>
</div>
</div>
<p>앞서 언급한 간선 정보를 가지며 4개의 노드를 사용하는 평면 그래프를
세 가지 색으로 칠하는 방법은 다음과 같다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backtracking_search_colors</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(int, {1: 1, 2: 2, 3: 3, 4: 2})
</pre></div>
</div>
</div>
</div>
<p>하지만 앞서 설명한 대로 두 가지 색으로는 칠할 수 없다.
즉, 아래 함수의 실행값이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="ow">not</span> <span class="n">backtracking_search_colors</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;두 가지 색으로 색칠 제약조건 충족 불가능&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>두 가지 색으로 색칠 제약조건 충족 불가능
</pre></div>
</div>
</div>
</div>
<p><strong>m-색칠 문제 되추적 알고리즘의 시간 복잡도</strong></p>
<p>n 개의 노드를 m 개의 색으로 칠해야 하는 문제의 상태 공간 트리의 노드의 수는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
1 + m + m^2 + m^3 + \cdots + m^n = \frac{m^{n+1}-1}{m-1}
\]</div>
<p>따라서 되추적 알고리즘이 최대 m과 n의 지승 만큼 많은 수의 노드를 탐색해야 할 수도 있다.
하지만 이보다 더 효율적인 알고리즘은 아직 알려지지 않았다.</p>
</section>
<section id="id4">
<h3><span class="section-number">22.4.2. </span>4색 정리<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<p>1852년에 영국인 프랜시스 구쓰리<font size='2'>Francis Guthrie</font>가 영국 지도를 작성할 때
인접한 두 개의 주를 서로 다른 색으로 칠하기 위해 필요한 색이 최소 4개면 된다는 4색 정리를 주장하였다.
하지만 이 4색 정리가 증명되기까지 124년이 걸렸다.</p>
<p><div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/england-4color-map.png" width="400"/></div></p>
<p><div style="text-align: center">&lt;그림 출처: <a href="https://www.gif-map.com/maps-of-europe/maps-of-united-kingdom/maps-of-england/administrative-map-of-england">Administrative map of England</a>&gt;</div></p><p>최초의 증명은 1976년에 K. Appel과 W. Haken이 제시하였다.
두 사람의 증명이 500 쪽 논문으로 제시되었는데 일부 내용은 컴퓨터 프로그램을 사용하도록 되어 있다.
그런데 증명에 사용된 컴퓨터 프로그램에 대한 신뢰성 때문에 오랜 시간동안 100% 인정받지 못하다가
2005년에 G. Gonthier에 의해 두 사람의 사용한 증명이 모두 옳았음이 검증되었다.</p>
</section>
</section>
<section id="id5">
<h2><span class="section-number">22.5. </span>연습문제<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://colab.research.google.com/github/codingalzi/algopy/blob/master/excs/exc-backtracking.ipynb">(실습) 되추적 기법</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="greedy_algorithm_3.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">21. </span>탐욕 기법 대 동적계획법</p>
      </div>
    </a>
    <a class="right-next"
       href="generic_programming.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">23. </span>제네릭 프로그래밍</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">22.1. 제약 충족 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">22.2. 되추적 기법</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#n">22.3. n-여왕말 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#m-4">22.4. m-색칠 문제와 4색 정리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#m">22.4.1. m-색칠 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">22.4.2. 4색 정리</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">22.5. 연습문제</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 코딩알지
</p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>