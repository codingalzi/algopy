

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>6. 시간 복잡도 &#8212; 문제해결 알고리즘</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'time_complexity';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. 차수" href="orders.html" />
    <link rel="prev" title="5. 덱(Deque)" href="deques.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    <p class="title logo__title">문제해결 알고리즘</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">파이썬 클래스와 추상 자료형</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="oop-classes-objects.html">1. 클래스, 인스턴스, 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="oop-inheritance.html">2. 상속</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">선형 자료 구조</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="queues.html">3. 큐(Queue)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks.html">4. 스택(Stack)</a></li>
<li class="toctree-l1"><a class="reference internal" href="deques.html">5. 덱(Deque)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">알고리즘 시간 복잡도</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">6. 시간 복잡도</a></li>
<li class="toctree-l1"><a class="reference internal" href="orders.html">7. 차수</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_list_dict.html">8. 파이썬 모음 자료형 분석</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">탐색과 정렬</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="sort_search_1.html">9. 탐색과 분할 정복</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort_search_2.html">10. 버블/선택/합병/퀵 정렬</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">트리, 힙, 맵</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_1.html">11. 트리(Tree)</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_2.html">12. 힙(Heap)</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_3.html">13. 맵(Map)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">재귀</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="recursive_functions.html">14. 재귀</a></li>
<li class="toctree-l1"><a class="reference internal" href="hanoi_tower.html">15. 하노이의 탑과 미로게임</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">동적계획법</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="dynamic_programming_1.html">16. 최적화 문제와 동적계획법</a></li>
<li class="toctree-l1"><a class="reference internal" href="dynamic_programming_2.html">17. 플로이드-워셜 알고리즘</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">탐욕 기법</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_1.html">18. 최소비용 신장트리</a></li>
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_2.html">19. 다익스트라 알고리즘</a></li>
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_3.html">20. 탐욕 기법 대 동적계획법</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">되추적 기법과 제네릭 프로그래밍</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="back_tracking.html">21. 되추적 기법</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic_programming.html">22. 제네릭 프로그래밍</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NP 이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="p_np.html">23. P-NP 문제</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/codingalzi/algopy/blob/master/jupyter-book/time_complexity.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/codingalzi/algopy" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/codingalzi/algopy/issues/new?title=Issue%20on%20page%20%2Ftime_complexity.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/time_complexity.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>시간 복잡도</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">6.1. 알고리즘 분석</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">6.1.1. 문제와 알고리즘</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">6.1.2. 컴퓨팅 자원</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">6.2. 시간복잡도</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#big-o">6.2.1. Big-O 표현식</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">6.2.2. 주요 시간복잡도 함수</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sec-running-time">6.2.3. 시간복잡도와 실행시간</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">6.3. 최선, 최악, 평균 시간복잡도</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">6.3.1. 순차 탐색</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">6.3.2. 어구전철</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">6.4. 공간 복잡도 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">6.5. 연습문제</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="sec-time-complexity">
<span id="id1"></span><h1><span class="section-number">6. </span>시간 복잡도<a class="headerlink" href="#sec-time-complexity" title="Permalink to this heading">#</a></h1>
<p><strong>주요 내용</strong></p>
<ul class="simple">
<li><p>알고리즘 분석</p></li>
<li><p>시간복잡도와 “Big-O”</p></li>
</ul>
<section id="id2">
<h2><span class="section-number">6.1. </span>알고리즘 분석<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<p>동일한 문제를 해결하는 프로그램 두 개의 성능을 어떻게 비교할 수 있을까? 라는 질문에 대답하려면
먼저 <strong>프로그램</strong>과 <strong>알고리즘</strong>의 차이점을 이해해야 한다.</p>
<ul class="simple">
<li><p>(컴퓨터) 프로그램</p>
<ul>
<li><p>주어진 문제를 해결하기 위해 <strong>특정</strong> 프로그래밍언어로 작성되어 실행이 가능한 코드</p></li>
<li><p>사용하는 프로그래밍언어와 작성자에 따른 여러 종류의 프로그램 존재</p></li>
<li><p>프로그램의 핵심은 문제해결을 위한 특정 알고리즘!</p></li>
<li><p>동일한 알고리즘을 이용하더라도 다르게 보이는 프로그램 구현 가능</p></li>
</ul>
</li>
<li><p>알고리즘</p>
<ul>
<li><p>주어진 <strong>문제를 해결하기 위한 절차</strong>의 단계별 설명서.</p></li>
<li><p>주어진 문제의 모든 경우를 해결할 수 있어야 함.</p>
<ul>
<li><p>예제: 최대공약수 구하기 문제를 해결하는 알고리즘은 특정한 두 정수의 최대공약수가 아닌
임의의 두 정수의 최대공약수를 계산해야 함.</p></li>
</ul>
</li>
<li><p>특정 프로그래밍언어 또는 프로그램 구현 방식과 무관함</p></li>
<li><p>주어진 문제를 해결하는 여러 종류의 알고리즘 존재 가능</p>
<ul>
<li><p>예제: 두 정수의 최대 공약수 구하기 알고리즘이 여러 방식 있음. 초등학교에서 배운 방식, 유클리드 호제법 방식 등</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<section id="id3">
<h3><span class="section-number">6.1.1. </span>문제와 알고리즘<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h3>
<p>예를 들어, ‘두 정수의 최대공약수 구하기’ <strong>문제</strong>를 해결하는 <strong>알고리즘</strong>은
임의의 두 정수에 대해 동일한 방식으로 최대공약수를 구해야 한다.
즉, 문제를 해결하는 알고리즘은 <strong>문제의 특정 사례</strong>에 의존하지 않아야 한다.</p>
<p>주어진 문제를 해결하는 여러 알고리즘이 존재할 수 있다.
아래 예제는 하나의 문제를 해결하는 두 개의 알고리즘을 보여준다.</p>
<p><strong>하나의 문제, 두 개의 알고리즘 예제: 최대공약수 구하기 문제</strong></p>
<p>최대공약수 구하기 문제를 해결하는 알고리즘은 <strong>임의의 두 정수에 대해 동일하게 작동</strong>하는 방식으로
최대공약수를 구하는 과정을 단계별로 설명한다.</p>
<ul class="simple">
<li><p>알고리즘 1: 초등학교에서 배운 방식</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/notebooks/_images/gcd_school.png" width="50%"></div>
<p>&lt;그림 출처: <a class="reference external" href="https://m.blog.naver.com/ict79/221927999240">아자수학</a>&gt;</p>
<ul class="simple">
<li><p>알고리즘 2: 유클리드 호제법 방식</p></li>
</ul>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/notebooks/_images/gcd_euclid.jpg" width="50%"></div>
<p>&lt;그림 출처: <a class="reference external" href="https://slidesplayer.org/slide/16641555/">SlidePlayer</a>&gt;</p>
<p>동일한 문제를 해결하는 두 개의 프로그램이 다르게 구현되었다고 해서
반드시 다른 알고리즘을 사용한 것이 아닐 수도 있다.
이어지는 예제는 동일한 알고리즘을 사용하는 두 개의 다른 프로그램을 보여준다.</p>
<p><strong>하나의 알고리즘, 두 개의 프로그램 예제: 1 부터 n 까지 합 구하기</strong></p>
<p>아래 두 프로그램 모두 양의 정수 n이 주어졌을 때 1부터 n까지를 대상으로 차례대로 더해가는 알고리즘을 구현한다.
&lt;프로그램 1&gt;은 매우 명료하게 작성되었다. 반면에 &lt;프로그램 2&gt;는 그렇지 않다.
무엇보다도 변수 이름이 적절하지 않고, 또 불필요한 변수를 반복과정에서 사용한다.</p>
<ul class="simple">
<li><p>프로그램 1</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_of_n</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">the_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">the_sum</span> <span class="o">=</span> <span class="n">the_sum</span> <span class="o">+</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">the_sum</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sum_of_n</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>55
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>프로그램 2</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">tom</span><span class="p">):</span>
    <span class="n">fred</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">bill</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">barney</span> <span class="o">=</span> <span class="n">bill</span>
        <span class="n">fred</span> <span class="o">=</span> <span class="n">fred</span> <span class="o">+</span> <span class="n">barney</span>

    <span class="k">return</span> <span class="n">fred</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>55
</pre></div>
</div>
</div>
</div>
<p>두 프로그램 중에서 어떤 프로그램이 보다 좋은 프로그램인가?
가독성, 명료성 등을 기준으로 보면 &lt;프로그램 1&gt;이 보다 좋은 프로그램이다.
가독성, 명료성이 물론 매우 중요한 기준이지만 여기서는
알고리즘 분석이라는 다른 기준을 소개한다.</p>
<p><strong>알고리즘 분석</strong>은 프로그램을 실행할 때 필요한 자원을 가리키는
<strong>컴퓨팅 자원</strong><font size='2'>computing resources</font>의 양과
활용의 효율성을 측정한다.
이 기준에서 보면 위 두 프로그램은 매우 유사한데, 이유는 두 프로그램 모두 동일한 알고리즘을 사용하기 때문이다.</p>
</section>
<section id="id4">
<h3><span class="section-number">6.1.2. </span>컴퓨팅 자원<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<p>컴퓨팅 자원이 의미하는 바는 두 가지이다.
아래 설명에서 사용되는 알고리즘의 입력값은 주어진 문제의 사례를 지정하는 값을 가리킨다.
예를 들어, 양의 정수 n이 주어지면 1부터 n까지의 합을 계산해야 하는 문제를 해결하는 알고리즘은
양의 정수 하나를 입력값으로 받는다.</p>
<p>그리고 <strong>입력 크기</strong><font size='2'>input size</font>,
즉 입력값의 크기는 입력값이 얼마나 큰지를 측정하는 기준에 따라 다르게 계산된다.
1부터 n까지의 합을 계산하는 알고리즘의 입력값인 정수 n의 크기는 n으로 정한다.
하지만 나중에 소개하는 알고리즘은 예를 들어 리스트를 입력값으로 사용하는데
그때 리스트의 크기는 리스트의 길이, 즉 리스트에 포함된 항목의 개수로 정한다.</p>
<ul class="simple">
<li><p>공간량</p>
<ul>
<li><p>알고리즘을 구현한 프로그램이 실행 될 때 요구되는 메모리, 저장 공간 등 공간의 양</p></li>
<li><p>알고리즘 실행에 사용되는 입력값의 크기에 의존</p></li>
</ul>
</li>
<li><p>실행시간</p>
<ul>
<li><p>알고리즘을 구현한 프로그램이 특정 결과를 반환할 때까지 걸리는 실행 시간</p></li>
<li><p>알고리즘 실행에 사용되는 입력값의 크기에 의존</p></li>
</ul>
</li>
</ul>
<p>여기서는 알고리즘 실행에 필요한 공간량에 대해서는 거의 다루지 않고 대신 실행시간에 대한 이야기에 집중한다.</p>
<p>파이썬 프로그램의 실행시간을 측정하는 가장 간단한 방식은 <code class="docutils literal notranslate"><span class="pre">time</span></code> 모듈의 <code class="docutils literal notranslate"><span class="pre">time()</span></code> 함수를 이용하는 것이다.
해당 함수는 실행될 때마다 측정된 컴퓨터 시간을 초 단위로 반환한다.
따라서 프로그램을 실행을 시작할 때와 종료할 때 두 번 측정한 결과의 차이가 실행시간이 된다.</p>
<p><strong>입력 크기에 따라 실행 시간이 달라지는 알고리즘</strong></p>
<p>아래 <code class="docutils literal notranslate"><span class="pre">sum_of_n_2()</span></code> 함수는 양의 정수 n이 주어졌을 때
1부터 n까지 정수의 합을 계산하기 위해 필요한 실행시간을 계산한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">sum_of_n_time</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>   <span class="c1"># 실행 시작</span>
    <span class="n">sum_of_n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>           <span class="c1"># 1부터 n까지의 합 계산</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>     <span class="c1"># 실행 종료</span>

    <span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>   <span class="c1"># 1부터 n까지의 합 계산에 필요한 시간</span>
</pre></div>
</div>
</div>
</div>
<p>알고리즘의 실행시간은 입력값에 의존한다.
아래 코드는 1부터 1만까지의 합을 계산하는 데 필요한 평균 시간을 측정한다.
평균을 계산하기 위해 1부터 1만까지의 합을 10번 실행한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time_sum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">time_sum</span> <span class="o">+=</span> <span class="n">sum_of_n_time</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1부터 </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">까지 더하는데 평균적으로 </span><span class="si">{</span><span class="n">time_sum</span><span class="o">/</span><span class="n">m</span><span class="si">:</span><span class="s2">7.5f</span><span class="si">}</span><span class="s2">초 걸림.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1부터 10000까지 더하는데 평균적으로 0.00030초 걸림.
</pre></div>
</div>
</div>
</div>
<p>10만까지의 합은 만까지의 합보다 대략 10배 정도 더 걸린다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time_sum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">time_sum</span> <span class="o">+=</span> <span class="n">sum_of_n_time</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1부터 </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">까지 더하는데 평균적으로 </span><span class="si">{</span><span class="n">time_sum</span><span class="o">/</span><span class="n">m</span><span class="si">:</span><span class="s2">7.5f</span><span class="si">}</span><span class="s2">초 걸림.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1부터 100000까지 더하는데 평균적으로 0.00309초 걸림.
</pre></div>
</div>
</div>
</div>
<p>100만까지의 합은 만까지의 합보다 100배 정도 더 걸린다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time_sum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">time_sum</span> <span class="o">+=</span> <span class="n">sum_of_n_time</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1부터 </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">까지 더하는데 평균적으로 </span><span class="si">{</span><span class="n">time_sum</span><span class="o">/</span><span class="n">m</span><span class="si">:</span><span class="s2">7.5f</span><span class="si">}</span><span class="s2">초 걸림.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1부터 1000000까지 더하는데 평균적으로 0.03106초 걸림.
</pre></div>
</div>
</div>
</div>
<p>따라서 1천만까지의 합은 평균적으로 만까지의 합보다 1000배 정도 오래 걸릴 것으로 추정할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">10000000</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">time_sum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">time_sum</span> <span class="o">+=</span> <span class="n">sum_of_n_time</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1부터 </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">까지 더하는데 평균적으로 </span><span class="si">{</span><span class="n">time_sum</span><span class="o">/</span><span class="n">m</span><span class="si">:</span><span class="s2">7.5f</span><span class="si">}</span><span class="s2">초 걸림.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1부터 10000000까지 더하는데 평균적으로 0.30962초 걸림.
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sum_of_n()</span></code> 함수가 실행될 때 사용된 반복 알고리즘의
반복 횟수에 따라 실행시간이 비례해서 늘어나는 것으로 보인다.
즉, 함수의 입력값의 크기에 실행시간이 선형적으로 의존한다.</p>
<p><strong>실행 시간이 입력 크기에 상관 없는 알고리즘</strong></p>
<p>모든 알고리즘이 입력값, 즉 주어진 문제의 사례에 의존해서 실행시간이 달라지는 것은 아니다.
아래 예제는 1부터 n까지의 합을 입력값 n에 상관없이 거의 동일한 시간 내에 계산하는 알고리즘을 사용한다.</p>
<p><strong>예제: 1 부터 n 까지 합 구하기</strong> (다른 알고리즘)</p>
<p><code class="docutils literal notranslate"><span class="pre">sum_of_n_3()</span></code> 함수는 1부터 n까지의 합을 계산하기 위해 아래 식을 이용한다.</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^{n} i = \frac {n\,(n+1)}{2}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_of_n_2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    
    <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
    
    <span class="k">return</span> <span class="nb">sum</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_of_n_2_time</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>            <span class="c1"># 실행 시작</span>
    <span class="n">sum_of_n_2</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
</pre></div>
</div>
</div>
</div>
<p>그런데 이 함수의 실행시간은 입력값에 의존하지 않는 것으로 보인다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">]:</span>
    <span class="n">time_sum</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">time_sum</span> <span class="o">+=</span> <span class="n">sum_of_n_2_time</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1부터 </span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">8d</span><span class="si">}</span><span class="s2">까지 더하는데 평균적으로 </span><span class="si">{</span><span class="n">time_sum</span><span class="o">/</span><span class="n">m</span><span class="si">:</span><span class="s2">.16f</span><span class="si">}</span><span class="s2">초 걸림.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1부터    10000까지 더하는데 평균적으로 0.0000000000000000초 걸림.
1부터   100000까지 더하는데 평균적으로 0.0000000000000000초 걸림.
1부터  1000000까지 더하는데 평균적으로 0.0000000000000000초 걸림.
1부터 10000000까지 더하는데 평균적으로 0.0000000000000000초 걸림.
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id5">
<h2><span class="section-number">6.2. </span>시간복잡도<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h2>
<p>계산 시간이 <code class="docutils literal notranslate"><span class="pre">sum_of_n()</span></code> 함수보다 훨씬 빠르다.
그런데 프로그램 실행시간은 사용되는 컴퓨터, 실행 환경, 컴파일러, 프로그래밍언어 등등에 의존하기 때문에 앞서
확인된 실행시간을 절대적인 기준으로 삼을 수는 없다.
따라서 이런 요소들에 의존하지 않으면서 객관적으로 프로그램의 실행시간을 평가하는 기준이 요구되는데
여기서는 시간복잡도를 사용한다.</p>
<p>주어진 알고리즘의 시간복잡도를 얘기하려면 먼저 기본 계산단위 개념을 이해해야 한다.</p>
<p><strong>기본 계산단위</strong></p>
<p>사용하는 컴퓨터 또는 프로그램에 의존하지 않으면서 알고리즘의 효율성을 실행시간을 이용하여 측정하려면
특정 연산자 또는 특정 명령문 등의 실행 횟수를 확인한다.
실행시간을 측정하기 위해 사용되는 연산자 또는 특정 명령문을
<strong>기본 계산단위</strong><font size='2'>basic unit of computation</font>라 부른다.
무엇을 기본 계산단위로 지정할 것인가는 알고리즘에 따라 다르며,
지정하는 일이 경우에 따라 매우 어려울 수도 있다.</p>
<p>예를 들어 앞서 살펴 본 <code class="docutils literal notranslate"><span class="pre">sum_of_n()</span></code> 함수의 경우에는 ‘변수 할당 명령문’을 기본 계산단위로 사용할 수 있는데
그러면 <code class="docutils literal notranslate"><span class="pre">sum_of_n(n)</span></code> 이 호출되면 실행되는 동안 총 (n+1) 번 변수 할당 명령문이 실행된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_of_n</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">the_sum</span> <span class="o">=</span> <span class="mi">0</span>                  <span class="c1"># 한 번 할당</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">the_sum</span> <span class="o">=</span> <span class="n">the_sum</span> <span class="o">+</span> <span class="n">i</span>    <span class="c1"># n 번 할당</span>

    <span class="k">return</span> <span class="n">the_sum</span>
</pre></div>
</div>
<p><strong>시간복잡도와 입력 크기</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">sum_of_n()</span></code> 함수의 입력값의 크기가 <span class="math notranslate nohighlight">\(n\)</span>일 때,
즉 <code class="docutils literal notranslate"><span class="pre">sum_of_n(n)</span></code>이 실행될 때 총 <span class="math notranslate nohighlight">\((n + 1)\)</span> 번 변수 할당 명령문이 실행되며,
이를 아래와 같이 나타낸다.</p>
<div class="math notranslate nohighlight">
\[
T(n) = n + 1
\]</div>
<p><span class="math notranslate nohighlight">\(T()\)</span> 함수는 ‘<strong>크기가 <span class="math notranslate nohighlight">\(n\)</span>인 입력값에 대해 <span class="math notranslate nohighlight">\(T(n)\)</span>의 시간이 지나면 해당 알고리즘이 반환값을 계산하고 종료한다</strong>’ 라는
의미를 갖는 <strong>일정 시간복잡도</strong> 함수이다.</p>
<p>따라서 <code class="docutils literal notranslate"><span class="pre">sum_of_n()</span></code> 함수의 일정 시간복잡도가 <span class="math notranslate nohighlight">\(T(n) = n + 1\)</span> 이라는 것은 다음을 의미한다.</p>
<div class="math notranslate nohighlight">
\[\text{입력 크기가 $n$인 문제를 해결하는 데에 필요한 시간이 $(n + 1)$이다.}\]</div>
<p><strong>알고리즘과 시간복잡도</strong></p>
<p>1부터 n까지의 합을 반복문을 이용해서 구하는 문제에서 입력값의 크기가 클 수록 실행시간도 그에 비례해서 오래 걸린다.
즉, 실행시간이 입력 크기에 의존한다.
반면에 아래에 사용된 알고리즘은 변수 할당을 전혀 사용하지 않는다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_of_n_2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="nb">sum</span>
</pre></div>
</div>
<p>실제로 위 프로그램의 실행시간과 입력 크기 사이의 관계는 <span class="math notranslate nohighlight">\(T(n) = 1\)</span>로 표현된다.</p>
<p><strong>예제: 일정 시간복잡도 계산</strong></p>
<p>아래 별 의미 없는 함수 <code class="docutils literal notranslate"><span class="pre">no_meaning()</span></code>의 일정 시간복잡도를 계산해보자.
기본 계산단위는 변수 할당으로 한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">no_meaning</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># 3번 할당</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="c1"># 3*n*n 번 할당</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span>

    <span class="c1"># 2n 번 할당</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">45</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span>

    <span class="c1"># 1번 할당</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">33</span>
    
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<p>코드에 주석으로 적혀 있는대로 <code class="docutils literal notranslate"><span class="pre">no_meaning()</span></code>함수가 입력값 <code class="docutils literal notranslate"><span class="pre">n</span></code>과 함께
호출되었을 때 실행하는 변수 할당의 총 횟수 <span class="math notranslate nohighlight">\(T(n)\)</span>은 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T(n) &amp;= 3 + 3n^{2} + 2n + 1 \\
 &amp;= 3n^{2} + 2n + 4
\end{align*}
\end{split}\]</div>
<section id="big-o">
<h3><span class="section-number">6.2.1. </span>Big-O 표현식<a class="headerlink" href="#big-o" title="Permalink to this heading">#</a></h3>
<p>입력 크기에 의존하는 실행시간 함수 <span class="math notranslate nohighlight">\(T(n)\)</span>의 정의에 사용되는 수식을 분석할 때
수식에 사용되는 모든 항을 다룰 필요가 없다.
예를 들어 <span class="math notranslate nohighlight">\(T(n) = n + 1\)</span> 에서 <span class="math notranslate nohighlight">\(1\)</span>은 별로 중요하지 않다.
실제로 <span class="math notranslate nohighlight">\(n\)</span>이 커질 수록 <span class="math notranslate nohighlight">\((n + 1)\)</span>에서 <span class="math notranslate nohighlight">\(1\)</span>의 역할은 거의 사라진다.
실제로 <span class="math notranslate nohighlight">\((n+1) / n\)</span>은 <span class="math notranslate nohighlight">\(n\)</span>이 커질 수로 1에 무한히 가까워진다.
이를 <strong>Big-O 표현식</strong>으로 나타내면 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
T(n) \in O(n)
\]</div>
<p>실행시간 함수 <span class="math notranslate nohighlight">\(T(n)\)</span>을 Big-O 표현식으로 나타내려면 앞서 설명한 것처럼 실행시간 계산에 있어서
입력 크기 <span class="math notranslate nohighlight">\(n\)</span>이 매우 커질 때 가장 중요한 역할을 수행하는 항인 찾아야 한다.
그런 항이 <span class="math notranslate nohighlight">\(f(n)\)</span> 이라 할 때 아래처럼 표기한다.</p>
<div class="math notranslate nohighlight">
\[
T(n) \in O(f(n))
\]</div>
<p><strong>예제</strong>: <span class="math notranslate nohighlight">\(T(n)=3n^{2} + 2n + 4\)</span></p>
<p><span class="math notranslate nohighlight">\(3n^{2} + 2n + 4\)</span>에서 <span class="math notranslate nohighlight">\(n\)</span>이 커질 때 <span class="math notranslate nohighlight">\(3 n^{2}\)</span>이 주도적 역할을 수행한다.
그런데 <span class="math notranslate nohighlight">\(3n^{2}\)</span>과 <span class="math notranslate nohighlight">\(n^{2}\)</span> 관계에서처럼 상수 배수는 무시된다.
이유는 동일한 알고리즘을 돌렸을 때 컴퓨터 사양에 따라 발생하는 몇 배 정도의 실행시간의 차이는
알고리즘 분석의 핵심으로 간주되지 않기 때문이다.</p>
<p>결론적으로 다음이 성립한다.</p>
<div class="math notranslate nohighlight">
\[
T(n) \in O(n^2)
\]</div>
<p><strong>예제</strong>: <span class="math notranslate nohighlight">\(T(n)=\frac{1}{1000}n \log n + 3n + 205\)</span></p>
<p><span class="math notranslate nohighlight">\(\frac{1}{1000}n \log n + 3n + 205\)</span>에서 <span class="math notranslate nohighlight">\(n\)</span>이 커질 때 가장 중요한 역할은
<span class="math notranslate nohighlight">\(\frac{1}{1000}n \log n\)</span>이 수행한다.
여기서 상수 배수를 무시하면 <span class="math notranslate nohighlight">\(n \log n\)</span> 이 실행시간 복잡도를 잘 대변하며,
따라서 다음이 성립한다.</p>
<div class="math notranslate nohighlight">
\[
T(n) \in O(n \log n)
\]</div>
<p><strong>예제</strong>: <span class="math notranslate nohighlight">\(T(n)=c\)</span>의 시간복잡도 (<span class="math notranslate nohighlight">\(c\)</span>는 상수)</p>
<p><code class="docutils literal notranslate"><span class="pre">sum_of_n_2()</span></code> 함수의 경우처럼 일정 시간복잡도가 입력 크기에 전혀 의존하지 않을 때
시간복잡도는 1이라고 말한다.
이유는 임의의 상수 <span class="math notranslate nohighlight">\(c\)</span>는 <span class="math notranslate nohighlight">\(1\)</span>의 상수 배수에 해당하고 앞서 설명하였듯이 상수 배수는
시간복잡도를 따질 때 무시되기 때문이다.
따라서 다음이 성립한다.</p>
<div class="math notranslate nohighlight">
\[
T(n) \in O(1)
\]</div>
</section>
<section id="id6">
<h3><span class="section-number">6.2.2. </span>주요 시간복잡도 함수<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h3>
<p>알고리즘 분석에 가장 많이 사용되는 주요 시간복잡도 함수는 다음과 같다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><strong>시간복잡도</strong></p></th>
<th class="head"><p><strong>의미</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(1\)</span></p></td>
<td><p>상수 시간</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\log n\)</span></p></td>
<td><p>로그 시간</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
<td><p>선형 시간</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(n\log n\)</span></p></td>
<td><p>로그선형 시간</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(n^{2}\)</span></p></td>
<td><p>2차 시간</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(n^{3}\)</span></p></td>
<td><p>3차 시간</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(2^{n}\)</span></p></td>
<td><p>지수 시간</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(n!\)</span></p></td>
<td><p>계승 시간</p></td>
</tr>
</tbody>
</table>
<p>아래 그림은 주요 Big-O 함수들이 <span class="math notranslate nohighlight">\(n\)</span>이 커질 수록 값이 어떤 차이를 보여주는가를 잘 보여준다.</p>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/notebooks/_images/big-o1.png" width="70%"></div>
<p>&lt;그림 출처: <a class="reference external" href="https://www.bigocheatsheet.com/">Big-O Cheat Sheet</a>&gt;</p>
</section>
<section id="sec-running-time">
<span id="id7"></span><h3><span class="section-number">6.2.3. </span>시간복잡도와 실행시간<a class="headerlink" href="#sec-running-time" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>가정: 기본 계산단위 실행시간 = 1 ns(나노 초, 10억 분의 1 초)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mu\)</span>s(마이크로 초): 100만 분의 1초</p></li>
<li><p>ms(밀리 초): 천 분의 1초</p></li>
</ul>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-right"><p>입력 크기(n)</p></th>
<th class="head text-right"><p><div style="width:80px"><span class="math notranslate nohighlight">\(\lg n\)</span></div></p></th>
<th class="head text-right"><p><div style="width:100px"><span class="math notranslate nohighlight">\(n\)</span></div></p></th>
<th class="head text-right"><p><div style="width:100px"><span class="math notranslate nohighlight">\(n\, \lg n\)</span></div></p></th>
<th class="head text-right"><p><div style="width:100px"><span class="math notranslate nohighlight">\(n^2\)</span></div></p></th>
<th class="head text-right"><p><div style="width:100px"><span class="math notranslate nohighlight">\(n^3\)</span></div></p></th>
<th class="head text-right"><p><div style="width:100px"><span class="math notranslate nohighlight">\(2^n\)</span></div></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(10\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.003\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.01\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.033\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.10\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.0\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
</tr>
<tr class="row-odd"><td class="text-right"><p><span class="math notranslate nohighlight">\(20\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.004\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.02\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.086\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.40\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(8.0\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1\)</span> ms</p></td>
</tr>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(30\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.005\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.03\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.147\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.90\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(27.0\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1\)</span> 초</p></td>
</tr>
<tr class="row-odd"><td class="text-right"><p><span class="math notranslate nohighlight">\(40\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.005\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.04\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.213\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.60\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(64.0\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(18.3\)</span> 분</p></td>
</tr>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(50\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.006\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.05\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.282\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(2.50\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(125.0\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(13\)</span> 일</p></td>
</tr>
<tr class="row-odd"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^2\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.007\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.10\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.664\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(10.00\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.0\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(4 \times 10^{13}\)</span> 년</p></td>
</tr>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^3\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.010\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.00\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(9.966\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.00\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.0\)</span> 초</p></td>
<td class="text-right"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^4\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.013\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(10.00\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(130.000\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(100.00\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(16.7\)</span> 분</p></td>
<td class="text-right"><p></p></td>
</tr>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^5\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.017\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.10\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.670\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(10.00\)</span> 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(11.6\)</span> 일</p></td>
<td class="text-right"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^6\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.020\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.00\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(19.930\)</span> ms</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(16.70\)</span> 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(31.7\)</span> 년</p></td>
<td class="text-right"><p></p></td>
</tr>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^7\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.023\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.01\)</span> 초</p></td>
<td class="text-right"><p>0.230 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.16\)</span> 일</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(31,709\)</span> 년</p></td>
<td class="text-right"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^8\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.027\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.10\)</span> 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(2.660\)</span> 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(115.70\)</span> 일</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(3.17 \times 10^7\)</span> 년</p></td>
<td class="text-right"><p></p></td>
</tr>
<tr class="row-even"><td class="text-right"><p><span class="math notranslate nohighlight">\(10^9\)</span></p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(0.030\)</span> <span class="math notranslate nohighlight">\(\mu\)</span>s</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(1.00\)</span> 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(29.900\)</span> 초</p></td>
<td class="text-right"><p><span class="math notranslate nohighlight">\(31.70\)</span> 년</p></td>
<td class="text-right"><p></p></td>
<td class="text-right"><p></p></td>
</tr>
</tbody>
</table>
<p>&lt;테이블 출처: <a class="reference external" href="http://www.hongpub.co.kr/shop/item.php?it_id=20170324151353">알고리즘 기초, Neopolitan 저, 홍릉</a>&gt;</p>
</section>
</section>
<section id="id8">
<h2><span class="section-number">6.3. </span>최선, 최악, 평균 시간복잡도<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h2>
<p>알고리즘의 시간복잡도가 입력 크기뿐만 아니라
입력값 자체에 의존하기도 한다.
이런 경우엔 일정 시간복잡도 <span class="math notranslate nohighlight">\(T(n)\)</span> 계산이 불가능하며,
대신에 최선, 최악, 평균 시간복잡도를 계산한다.</p>
<p>순차 탐색과 어구전철 확인 두 예제를 이용하여 최선, 최악, 평균 시간복잡도를 설명한다.</p>
<section id="id9">
<h3><span class="section-number">6.3.1. </span>순차 탐색<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h3>
<p>주어진 리스트에서 특정 값의 포함 여부를 판단할 때
인덱스를 따라가면서 해당 항목을 확인할 수 있다.
이를 <strong>순차 탐색</strong>이라 하며 다음 그림처럼 작동한다.</p>
<div align="center"><img src="https://runestone.academy/runestone/books/published/pythonds/_images/seqsearch.png" width="70%"></div><p>순차 탐색 알고리즘을 아래 함수로 구현할 수 있다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alist</span></code>: 주어진 리스트</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">item</span></code>: 탐색 대상 값</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos=0</span></code>: 탐색 대상 인덱스. 0부터 출발해서 리스트 길이만큼 1식 증가.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">found=False</span></code>: 지정된 값의 포함 여부. 기본은 <code class="docutils literal notranslate"><span class="pre">False</span></code>, 찾으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 전환.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sequentialSearch</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">alist</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>             <span class="c1"># 값 비교 계산단위</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">found</span>
</pre></div>
</div>
</div>
</div>
<p>아래와 같이 활용된다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">testlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">54</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span>
<span class="n">testlist_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">93</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sequentialSearch</span><span class="p">(</span><span class="n">testlist</span><span class="p">,</span> <span class="mi">93</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sequentialSearch</span><span class="p">(</span><span class="n">testlist_sorted</span><span class="p">,</span> <span class="mi">93</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sequentialSearch()</span></code> 함수의 일정 시간복잡도 <span class="math notranslate nohighlight">\(T(n)\)</span>을 계산해 보자.</p>
<ul class="simple">
<li><p>입력 크기 <span class="math notranslate nohighlight">\(n\)</span>: 첫째인자, 즉 리스트의 길이</p></li>
<li><p>기본 계산단위: 리스트의 항목 확인과 비교. 즉, while 문 안에 있는 if 문의 <code class="docutils literal notranslate"><span class="pre">alist[pos]</span> <span class="pre">==</span> <span class="pre">item</span></code>를 기본 계산단위로 사용.</p></li>
</ul>
<p>그런데 <code class="docutils literal notranslate"><span class="pre">sequentialSearch(testlist,</span> <span class="pre">93)</span></code>을 실행하면 세 번 비교가 발생한다.
반면에 <code class="docutils literal notranslate"><span class="pre">sequentialSearch(testlist_sorted,</span> <span class="pre">93)</span></code>을 실행하면 열 번 비교한다.
즉, 동일한 길이의 리스트를 사용하더라도 리스트에 포함된 항목들의 순서에 따라 실행시간이 달라진다.</p>
<p>이런 경우엔 일정 시간복잡도 <span class="math notranslate nohighlight">\(T(n)\)</span>을 계산할 수 없으며,
대신 입력 크기 <span class="math notranslate nohighlight">\(n\)</span>에 의존하는 시간복잡도의 최솟값, 최댓값, 평균값 함수를 구해야 한다.
이를 각각 해당 알고리즘의 <strong>최선</strong>(best), <strong>최악</strong>(worst), <strong>평균</strong>(average) 시간복잡도라 한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">sequentialSearch()</span></code> 함수의 최선, 최악, 평균 시간 복잡도를 리스트의 길이에 대한 함수로
계산하면 다음과 같다.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p></p></th>
<th class="head text-center"><p>최선</p></th>
<th class="head text-center"><p>최악</p></th>
<th class="head text-center"><p>평균</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>항목인 경우</p></td>
<td class="text-center"><p>1</p></td>
<td class="text-center"><p>n</p></td>
<td class="text-center"><p>n/2</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>항목이 아닌 경우</p></td>
<td class="text-center"><p>n</p></td>
<td class="text-center"><p>n</p></td>
<td class="text-center"><p>n</p></td>
</tr>
</tbody>
</table>
<p>주어진 알고리즘의 최대, 최소, 평균 시간복잡도를 각각 <span class="math notranslate nohighlight">\(B(n)\)</span>, <span class="math notranslate nohighlight">\(W(n)\)</span>, <span class="math notranslate nohighlight">\(A(n)\)</span>이라 했을 때 다음이 성립한다.</p>
<ul>
<li><p>일정 시간복잡도 <span class="math notranslate nohighlight">\(T(n)\)</span>이 존재할 때:</p>
<div class="math notranslate nohighlight">
\[T(n) = B(n) = A(n) = W(n)\]</div>
</li>
<li><p>일정 시간복잡도 <span class="math notranslate nohighlight">\(T(n)\)</span>이 존재하지 않을 때:</p>
<div class="math notranslate nohighlight">
\[B(n) \le A(n) \le W(n)\]</div>
</li>
</ul>
</section>
<section id="id10">
<h3><span class="section-number">6.3.2. </span>어구전철<a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h3>
<p><strong>어구전철</strong>은 단어를 구성하는 문자의 순서를 바꾸어 새로운 단어를 생성하는 것을 나타내며,
영어로 <strong>애너그램</strong>(anagram)이라 한다.
예를 들어 “국왕” 과 “왕국”, “감동”과 “동감”, “다들 힘내”와 “내 힘들다”,
“heart”와 “earth”, “python”과 “typhon” 등이 어구전철 관계를 갖는다.
여기서는 두 영어 단어의 어구전철 여부를 확인하는 함수를
다양한 알고리즘을 이용하여 구현한다.</p>
<p><strong>방법 1: 일일이 확인하기</strong></p>
<p>첫째 방법은 하나의 문자열에 사용된 모든 문자를 대상으로
해당 문자가 다른 문자열에 나타나는가를 일일이 확인하는 것이다.
그리고 확인된 문자는 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 대체해서 더 이상 확인 대상이 되지 않도록 한다.</p>
<ul class="simple">
<li><p>먼저 <code class="docutils literal notranslate"><span class="pre">s1</span></code>과 <code class="docutils literal notranslate"><span class="pre">s2</span></code> 두 문자열의 길이 비교. 다르면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 반환</p></li>
<li><p>둘째 문자열 <code class="docutils literal notranslate"><span class="pre">s2</span></code>를 리스트로 변환. 파이썬의 문자열은 수정불가능이기 때문에 리스트를 대신 사용.</p></li>
<li><p>첫째 문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>에 포함된 문자를 대상으로 둘째 문자열의 리스트 <code class="docutils literal notranslate"><span class="pre">s2</span></code>에 포함되어 있는지 탐색 시작</p>
<ul>
<li><p>리스트 <code class="docutils literal notranslate"><span class="pre">s2</span></code>에서 찾았으면 해당 문자를 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 대체 후 바로 문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>의 다음 문자를 대상으로 탐색 반복</p></li>
<li><p>아니면 해당 문자까지만 탐색하고 실행 종료</p></li>
</ul>
</li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">anagram_solution_1</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="n">still_ok</span> <span class="o">=</span> <span class="kc">True</span>           <span class="c1"># 첫째 문자열에 포함된 문자 대상 어구전철 여부 저장</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>    <span class="c1"># 동일한 길이 여부 확인</span>
        <span class="n">still_ok</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">s2_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>         <span class="c1"># 둘째 문자열을 리스트로 변환</span>
    <span class="n">pos_1</span> <span class="o">=</span> <span class="mi">0</span>                 <span class="c1"># 현재 확인 위치 저장</span>

    <span class="k">while</span> <span class="n">pos_1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">still_ok</span><span class="p">:</span>             <span class="c1"># 첫째 문자열의 모든 문자 대상 반복</span>
        <span class="n">pos_2</span> <span class="o">=</span> <span class="mi">0</span>                                 
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">while</span> <span class="n">pos_2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2_list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>    <span class="c1"># 둘째 문자열의 모든 문자 대상 비교</span>
            <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">pos_1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2_list</span><span class="p">[</span><span class="n">pos_2</span><span class="p">]:</span>          <span class="c1"># 기본 계산단위: 비교</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos_2</span> <span class="o">=</span> <span class="n">pos_2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">s2_list</span><span class="p">[</span><span class="n">pos_2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">still_ok</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">pos_1</span> <span class="o">=</span> <span class="n">pos_1</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">still_ok</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_1</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">,</span> <span class="s2">&quot;pleap&quot;</span><span class="p">))</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_1</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;dcba&quot;</span><span class="p">))</span>    <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_1</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;dcda&quot;</span><span class="p">))</span>    <span class="c1"># False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
False
</pre></div>
</div>
</div>
</div>
<p>위 알고리즘 분석에 사용되는 기본 계산단위로
첫째 문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>의 항목과 둘째 문자열로부터 변환된
리스트 <code class="docutils literal notranslate"><span class="pre">s2_list</span></code>의 항목 사이의 비교연산(<code class="docutils literal notranslate"><span class="pre">==</span></code>)을 사용한다.
두 문자열의 길이가 <span class="math notranslate nohighlight">\(n\)</span>이라 하자.
다음 세 가지 경우를 고려해야 한다.</p>
<ul>
<li><p>두 문자열이 서로 어구전철일 때</p>
<p>문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>의 각 문자에 대해 리스트 <code class="docutils literal notranslate"><span class="pre">s2_list</span></code>의 각 항목을 비교해야 한다.
그리고 문자의 위치에 따라 1번에서 최대 <span class="math notranslate nohighlight">\(n\)</span>번까지 비교연산이 실행되며,
모든 경우가 발생한다.즉, 다음이 성립한다.</p>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T(n) &amp;= \sum_{i=1}^{n} i \\
    &amp;= \frac {n(n+1)}{2} \\
    &amp; = \frac {1}{2}n^{2} + \frac {1}{2}n \\
    &amp; \in O(n^{2})
\end{align*}
\end{split}\]</div>
<ul>
<li><p>두 문자열의 길이가 같지만 서로 어구전철 관계가 아닐 때</p>
<ul>
<li><p>최선: 문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>의 첫째 문자가 리스트 <code class="docutils literal notranslate"><span class="pre">s2_list</span></code>에 포함되지 않은 경우에
어구전철이 아니라고 판단된다.
따라서 다음이 성립한다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
        B(n) = n\\
        \end{split}\]</div>
</li>
<li><p>최악: 첫째 문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>의 마지막 문자가 리스트 <code class="docutils literal notranslate"><span class="pre">s2_list</span></code>에 포함되지 않은 경우에
어구전철이 아니라고 판단된다.
처음 <span class="math notranslate nohighlight">\((n-1)\)</span>개의 문자를 확인하는데 걸리는 최악 시간은</p>
<div class="math notranslate nohighlight">
\[
        2 + 3 + \cdots + n
        \]</div>
<p>이며, 마지막 문자가 <code class="docutils literal notranslate"><span class="pre">s2_list</span></code>에 없는 것을 확인하는 데에 <span class="math notranslate nohighlight">\(n\)</span> 번의 비교가 요구된다.
따라서 다음이 성립한다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
        \begin{align*}
        W(n) &amp;= 2 + 3 + \cdots + n + n\\
            &amp;= \frac {n(n+1)}{2} - 1 + n \\
            &amp; = \frac {1}{2}n^{2} + \frac {3}{2}n - 1\\
            &amp; \in O(n^{2})
        \end{align*}
        \end{split}\]</div>
</li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>두 문자열의 길이가 다를 때: 바로 어구전철이 아니다 라고 판단된다.</p></li>
</ul>
<p><strong>방법 2: 정렬 후 비교</strong></p>
<p>서로 어구전철인 두 문자열을 동일한 문자들을 포함해야 한다.
따라서 알파벳 순서대로 문자들을 정렬하면 완전히 동일한 두 문자열을 얻게 된다.
아래 알고리즘은 먼저 두 문자열을 리스트로 형변환한 후에
리스트의 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 메서드를 이용하여 두 문자열을 정렬한다.
그런 다음에 각 인덱스에 대해 정렬된 두 문자열이 동일한 문자를 갖는지
확인한다. 중간에 서로 다른 문자를 확인하면 바로 실행을 멈춘다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">anagram_solution_2</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="c1"># 리스트로 형변환</span>
    <span class="n">a_list_1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="n">a_list_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

    <span class="c1"># 리스트 정렬</span>
    <span class="n">a_list_1</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">a_list_2</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># 동일 위치에 대해 일대일 비교. 다르면 바로 종료</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a_list_1</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">a_list_2</span><span class="p">[</span><span class="n">pos</span><span class="p">]:</span>    <span class="c1"># 기본 계산단위: 비교</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">matches</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_2</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">,</span> <span class="s2">&quot;pleap&quot;</span><span class="p">))</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_2</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;dcba&quot;</span><span class="p">))</span>    <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_2</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;dcda&quot;</span><span class="p">))</span>    <span class="c1"># False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
False
</pre></div>
</div>
</div>
</div>
<p>두 문자열이 서로 어구전철인 경우 비교 연산자가 <span class="math notranslate nohighlight">\(n\)</span> 번 발생하는 것으로 보인다.
하지만 <code class="docutils literal notranslate"><span class="pre">sort()</span></code> 함수를 이용한 정렬 과정 중에도 많은 비교가 발생한다.
실제로 대부분의 정렬 알고리즘은 <span class="math notranslate nohighlight">\(O(n^2)\)</span> 또는 <span class="math notranslate nohighlight">\(O(n\log n)\)</span>의
시간복잡도를 갖는다.
따라서 위 알고리즘이 시간복잡도는 사용되는 정렬 알고리즘의 시간복잡도와 동일하다.</p>
<p><strong>방법 3: 부르트 포스 기법</strong></p>
<p><strong>부르트 포스</strong>(brute force) 기법은 모든 가능한 경우를 일일이 나열해보는 방법을 의미한다.
예를 들어 문자열 <code class="docutils literal notranslate"><span class="pre">s1</span></code>에 사용된 문자들의 모든 조합을 생성한 다음에 그 중에 문자열 <code class="docutils literal notranslate"><span class="pre">s2</span></code>가
있는가를 확인하는 방식도 부르트 포스 기법을 따른다.</p>
<p>하지만 이 알고리즘은 일단 모든 조합의 문자열을 생성하는 것부터 어렵다.
왜냐하면 주어진 <span class="math notranslate nohighlight">\(n\)</span> 개의 문자를 이용하여 생성할 수 있는 문자열의 개수는 다음과
같기 때문이다.</p>
<div class="math notranslate nohighlight">
\[
n \cdot (n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1 = n!
\]</div>
<p>예를 들어 다음이 성립한다.</p>
<div class="math notranslate nohighlight">
\[20! = 2,432,902,008,176,640,000\]</div>
<p>즉, 하나의 문자열을 생성하여 문자열 <code class="docutils literal notranslate"><span class="pre">s2</span></code>와 비교하는 데에 100만 분의 1초가 걸린다고 가정했을 때,
길이가 20인 두 개의 문자열의 어구전철 관계를 확인하려면
대략 77,147 년이 걸린다.</p>
<p><strong>방법 4: 빈도수와 비교</strong></p>
<p>어구전철 관계인 두 문자열은 각 문자를 동일한 수만큼 포함한다.
따라서 모든 알파벳에 대해 각 문자열에 포함된 빈도를 측정한 후에
측정된 빈도가 모든 문자에 대해 일치하는지를 확인하면 된다.</p>
<p>26개의 알파벳이 존재하기에 각 문자열에 대해
길이가 26인 리스트를 생성한 후에 각 문자에 대한 빈도를 카운트한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ord()</span></code> 함수: 문자와 정수를 연결하는 함수</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ord(x)</span> <span class="pre">-</span> <span class="pre">ord(&quot;a&quot;)</span></code>: <code class="docutils literal notranslate"><span class="pre">x</span></code>가 몇 번째 알파벳인지 계산.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">anagram_solution_4</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    
    <span class="c1"># 빈도수 저장 용도 리스트</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>

    <span class="c1"># s1에 포함된 문자들의 빈도수</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">c1</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># 기본 계산단위: 카운트</span>

    <span class="c1"># s2에 포함된 문자들의 빈도수</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1"># 기본 계산단위: 카운트</span>

    <span class="c1"># 모든 알파벳 대상 빈도수 비교</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">still_ok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">still_ok</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">c2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>             <span class="c1"># 기본 계산단위: 항목 비교</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">still_ok</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">still_ok</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_4</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">,</span> <span class="s2">&quot;pleap&quot;</span><span class="p">))</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_4</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;dcba&quot;</span><span class="p">))</span>    <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">anagram_solution_4</span><span class="p">(</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;dcda&quot;</span><span class="p">))</span>    <span class="c1"># False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
False
</pre></div>
</div>
</div>
</div>
<p>길이가 <span class="math notranslate nohighlight">\(n\)</span>인 문자열에 포함된 문자들의 빈도를 확인하는 시간복잡도는
카운트를 기준으로 했을 때 <span class="math notranslate nohighlight">\(O(n)\)</span>이다.
그리고 두 개의 카운트 리스트를 비교하는 데에 최소 1번, 최대 26번의 항목 비교가 발생한다.
따라서 위 어구전철인 두 개의 문자열을 확인하는 알고리즘의 시간복잡도는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[
T(n) = 2n + 26 \in O(n)
\]</div>
</section>
</section>
<section id="id11">
<h2><span class="section-number">6.4. </span>공간 복잡도 문제<a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h2>
<p>알고리즘 <code class="docutils literal notranslate"><span class="pre">anagram_solution_4()</span></code>의 시간복잡도는 이전 세 알고리즘에 비해 훨씬 좋다.
하지만 그 대신에 빈도 리스트를 새로 생성하기 위해 보다 많은 메모리를 사용한다.
여기서는 겨우 길이가 26인 리스트 두 개를 생성하기에 별 문제가 아니지만
경우에 따라 길이가 수 백만, 수 천만, 수 억인 리스트를 생성해야 한다면 심각한 문제가 될 수도 있다.</p>
<p>하지만 이전 알고리즘들도 모두 추가 메모리를 사용한다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">anagram_solution_1()</span></code>: 문자열 <code class="docutils literal notranslate"><span class="pre">s2</span></code>를 리스트로 변환한 값</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anagram_solution_2()</span></code>: 두 문자열을 리스트로 형변환한 후 정렬.
그리고 정렬 과정에서 추가 메모리 사용 가능.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anagram_solution_3()</span></code>: 실제로 알고리즘을 구현하면 모든 가능한 조합을 생성하거나 저장할 때
추가 메모리 요구될 것임.</p></li>
</ul>
<p>따라서 어떤 알고리즘을 사용하는 게 좋을지 환경과 상황에 따라 결정해야 한다.</p>
</section>
<section id="id12">
<h2><span class="section-number">6.5. </span>연습문제<a class="headerlink" href="#id12" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://colab.research.google.com/github/codingalzi/algopy/blob/master/excs/exc-time_complexity.ipynb">(실습) 시간 복잡도</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="deques.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">5. </span>덱(Deque)</p>
      </div>
    </a>
    <a class="right-next"
       href="orders.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">7. </span>차수</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">6.1. 알고리즘 분석</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">6.1.1. 문제와 알고리즘</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">6.1.2. 컴퓨팅 자원</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">6.2. 시간복잡도</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#big-o">6.2.1. Big-O 표현식</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">6.2.2. 주요 시간복잡도 함수</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sec-running-time">6.2.3. 시간복잡도와 실행시간</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">6.3. 최선, 최악, 평균 시간복잡도</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">6.3.1. 순차 탐색</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">6.3.2. 어구전철</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">6.4. 공간 복잡도 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">6.5. 연습문제</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 코딩알지
</p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>