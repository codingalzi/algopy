
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>19. 플로이드-워셜 알고리즘 &#8212; 문제해결 알고리즘</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'dynamic_programming_2';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="20. 최소비용 신장트리" href="greedy_algorithm_1.html" />
    <link rel="prev" title="18. 최적화 문제와 동적계획법" href="dynamic_programming_1.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">문제해결 알고리즘</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">파이썬 클래스와 추상 자료형</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="oop-classes-objects.html">1. 클래스, 인스턴스, 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="oop-inheritance.html">2. 상속</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">선형 자료 구조</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="queues.html">3. 큐(Queue)</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacks.html">4. 스택(Stack)</a></li>
<li class="toctree-l1"><a class="reference internal" href="deques.html">5. 덱(Deque)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">알고리즘 시간 복잡도</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="time_complexity.html">6. 시간 복잡도</a></li>
<li class="toctree-l1"><a class="reference internal" href="orders.html">7. 차수</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_list_dict.html">8. 파이썬 모음 자료형 분석</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">재귀</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="recursive_functions_1.html">9. 재귀 함수</a></li>
<li class="toctree-l1"><a class="reference internal" href="recursive_functions_2.html">10. 재귀 시각화</a></li>
<li class="toctree-l1"><a class="reference internal" href="hanoi_tower.html">11. 하노이의 탑과 미로게임</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">탐색과 정렬</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="sort_search_1.html">12. 탐색과 분할 정복</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort_search_2.html">13. 버블/선택/합병/퀵 정렬</a></li>
<li class="toctree-l1"><a class="reference internal" href="sort_search_3.html">14. 깊이 우선 vs. 너비 우선</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">트리, 힙, 맵</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_1.html">15. 트리(Tree)</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_2.html">16. 힙(Heap)</a></li>
<li class="toctree-l1"><a class="reference internal" href="trees_heaps_maps_3.html">17. 맵(Map)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">동적계획법</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="dynamic_programming_1.html">18. 최적화 문제와 동적계획법</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">19. 플로이드-워셜 알고리즘</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">탐욕 기법</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_1.html">20. 최소비용 신장트리</a></li>
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_2.html">21. 다익스트라 알고리즘</a></li>
<li class="toctree-l1"><a class="reference internal" href="greedy_algorithm_3.html">22. 탐욕 기법 대 동적계획법</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">되추적 기법과 제네릭 프로그래밍</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="backtracking.html">23. 되추적 기법</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic_programming.html">24. 제네릭 프로그래밍</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NP 이론</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="p_np.html">25. P-NP 문제</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/codingalzi/algopy/blob/master/jupyter-book/dynamic_programming_2.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Colab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Colab logo" src="_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/codingalzi/algopy" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/codingalzi/algopy/issues/new?title=Issue%20on%20page%20%2Fdynamic_programming_2.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/dynamic_programming_2.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>플로이드-워셜 알고리즘</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">19.1. 그래프 용어</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">19.2. 최단 경로 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">19.3. 플로이드-워셜 알고리즘</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">19.4. 최적의 원칙</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">19.5. 연습 문제</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="sec-dynamic-programming-2">
<span id="id1"></span><h1><span class="section-number">19. </span>플로이드-워셜 알고리즘<a class="headerlink" href="#sec-dynamic-programming-2" title="Link to this heading">#</a></h1>
<p><strong>슬라이드</strong></p>
<p>본문 내용을 요약한 <a class="reference external" href="https://github.com/codingalzi/algopy/raw/master/slides/slides-dynamic_programming_2.pdf">슬라이드</a>를 다운로드할 수 있다.</p>
<p><strong>주요 내용</strong></p>
<ul class="simple">
<li><p>방향 그래프</p></li>
<li><p>최단 경로 문제</p></li>
<li><p>플로이드-워셜 알고리즘</p></li>
<li><p>최적의 원칙</p></li>
</ul>
<section id="id2">
<h2><span class="section-number">19.1. </span>그래프 용어<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>그래프 관련 용어를 익혀두어야 한다.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p>용어</p></th>
<th class="head text-left"><p>개념</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>노드<font size='2'>node</font></p></td>
<td class="text-left"><p>그래프의 구성 요소. 꼭짓점<font size='2'>vertex</font> 또는 정점으로도 불림.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>간선<font size='2'>edge</font></p></td>
<td class="text-left"><p>두 개의 노드를 연결하는 선. 이음선 또는 변으로도 불림.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>방향 그래프<font size='2'>directed graph</font></p></td>
<td class="text-left"><p>간선의 방향이 정해진 그래프</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>무방향 그래프<font size='2'>undirected graph</font></p></td>
<td class="text-left"><p>간선의 방향이 없는 그래프</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>가중치<font size='2'>weight</font></p></td>
<td class="text-left"><p>간선에 추가된 숫자</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>가중 그래프<font size='2'>weighted graph</font></p></td>
<td class="text-left"><p>가중치가 있는 간선을 사용하는 그래프</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>경로<font size='2'>path</font></p></td>
<td class="text-left"><p>간선으로 연결된 노드들의 나열. 즉, 하나의 노드에서 다른 노드로 가는 간선들의 연결.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>단순 경로<font size='2'>simple path</font></p></td>
<td class="text-left"><p>같은 노드를 두 번 지나지 않는 경로</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>순환<font size='2'>cycle</font></p></td>
<td class="text-left"><p>경로에 포함된 노드 중에서 출발 노드와 도착 노드만 동일한 경로</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>순환 그래프<font size='2'>cyclic graph</font></p></td>
<td class="text-left"><p>순환이 포함된 그래프</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p>비순환 그래프 <font size='2'>acyclic graph</font></p></td>
<td class="text-left"><p>순환이 포함되지 않은 그래프</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p>경로의 길이</p></td>
<td class="text-left"><p>가중 그래프의 경우엔 경로 상에 있는 가중치의 합, 비가중 그래프의 경우엔 경로 상에 있는 이음선의 수</p></td>
</tr>
</tbody>
</table>
</div>
<p>예를 들어 가중 방향 그래프는 다음과 같이 생겼다.</p>
<p>참고: 아래 코드는 <code class="docutils literal notranslate"><span class="pre">graphviz</span></code> 라이브러리를 이용하여 그래프를 그려준다.
알고리즘 이해와는 상관없기에 코드가 아닌 그래프 결과물에만 집중하면 된다.
단, graphviz 파이썬 모듈과 프로그램이 컴퓨터에 설치되어 있어야 한다.</p>
<ul class="simple">
<li><p>graphviz 파이썬 모듈 설치: pip install graphviz</p></li>
<li><p>운영체제에 따른 graphviz 프로그램 설치: <a class="reference external" href="https://graphviz.gitlab.io/download/">https://graphviz.gitlab.io/download/</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">graphviz</span> 

<span class="k">def</span> <span class="nf">save_graph_as_svg</span><span class="p">(</span><span class="n">dot_string</span><span class="p">,</span> <span class="n">output_file_name</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dot_string</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">dot_string</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dot_string</span><span class="p">,</span> <span class="p">(</span><span class="n">graphviz</span><span class="o">.</span><span class="n">dot</span><span class="o">.</span><span class="n">Digraph</span><span class="p">,</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">dot</span><span class="o">.</span><span class="n">Graph</span><span class="p">)):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">dot_string</span>
    <span class="n">g</span><span class="o">.</span><span class="n">format</span><span class="o">=</span><span class="s1">&#39;svg&#39;</span>
    <span class="c1"># 이미지 저장 경로 지정</span>
    <span class="n">g</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">output_file_name</span>
    <span class="n">g</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="s1">&#39;./imgs&#39;</span>
    <span class="n">g</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">view</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digraph1</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">()</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v3&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v4&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="s2">&quot;v3&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="s2">&quot;v4&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;5&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;9&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="s2">&quot;v3&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="s2">&quot;v3&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;4&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v3&quot;</span><span class="p">,</span> <span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v3&quot;</span><span class="p">,</span> <span class="s2">&quot;v4&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v4&quot;</span><span class="p">,</span> <span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>

<span class="n">save_graph_as_svg</span><span class="p">(</span><span class="n">digraph1</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;weighted_directed_graph_01&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/8265e41de132905ebc6b2608bd476f28d60bfec0255f129a57e29b371e2820db.svg" src="_images/8265e41de132905ebc6b2608bd476f28d60bfec0255f129a57e29b371e2820db.svg" />
</div>
</div>
</section>
<section id="id3">
<h2><span class="section-number">19.2. </span>최단 경로 문제<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>방향 그래프가 주어졌을 때
임의의 노드에서 다른 임의의 노드로 가는 최단 경로를 구하는 문제이다.
이때 간선의 가중치와 방향을 함께 고려한다.
비가중 방향 그래프의 경우 모든 간선의 가중치가 1이라고 간주한다.
최단 경로는 순환을 포함하지 않는 단순 경로만 대상으로 최단 경로를 찾는다.
최단 경로 계산 알고리즘은 예를 들어 두 도시 간의 최단 경로를 찾아야 할 때 활용될 수 있다.</p>
<p>위 가중 방향 그래프에서 <span class="math notranslate nohighlight">\(v_0\)</span>에서 <span class="math notranslate nohighlight">\(v_2\)</span>로 가는 단순 경로는 다음 세 종류이다.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(v_0 \to v_1 \to v_2\)</span>: 경로 길이는 1 + 3 = 4.</p></li>
<li><p><span class="math notranslate nohighlight">\(v_0 \to v_3 \to v_2\)</span>: 경로 길이는 1 + 2 = 3.</p></li>
<li><p><span class="math notranslate nohighlight">\(v_0 \to v_1 \to v_3 \to v_2\)</span>: 경로 길이는 1 + 2 + 2 = 5.</p></li>
</ul>
<p>이중에서 <span class="math notranslate nohighlight">\(v_0 \to v_3 \to v_2\)</span>가 <span class="math notranslate nohighlight">\(v_0\)</span>에서 <span class="math notranslate nohighlight">\(v_2\)</span>로 가는 최단 경로이다.</p>
<p><strong>완전 탐색</strong></p>
<p>완전 탐색<font size='2'>brute force</font> 알고리즘은
두 노드 사이의 가능한 모든 경로의 길이를 계산한 후 그 중에 최단 경로를 선택한다.
하지만 이 알고리즘은 지수 함수보다 나쁜 시간복잡도를 가진다.</p>
<p>예를 들어 <span class="math notranslate nohighlight">\(v_0, v_1, ..., v_{n-1}\)</span>을 노드로 사용하고 모든 노드들 사이에 간선이 존재하는 그래프를 고려하자.
이때 <span class="math notranslate nohighlight">\(v_0\)</span>에서 <span class="math notranslate nohighlight">\(v_{n-1}\)</span>으로 가는 경로 중에서 나머지 모든 노드를 한 번씩 꼭 거쳐서 가는 경로들의 수는
다음과 같이 계산된다.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(v_0\)</span> 에서 출발하여 첫 경유지로 사용될 수 있는 노드의 수는 <span class="math notranslate nohighlight">\((n-2)\)</span> 개</p></li>
<li><p>그 중에 하나를 선택하면, 그 다음 경유지로 사용될 수 있는 노드의 가지 수는 <span class="math notranslate nohighlight">\((n-3)\)</span>개</p></li>
<li><p>…</p></li>
</ul>
<p>따라서 총 경로의 개수는 다음과 같다.</p>
<div class="math notranslate nohighlight">
\[(n-2)\cdot(n-3)\cdots 2\cdot 1= (n-2)!\]</div>
<p>두 노드 사이의 최단 경로를 동적계획법으로 계산하기 위해
주어진 방향 그래프의 <strong>인접 행렬</strong><font size='2'>adjacent matrix</font>을
동적계획법 기법으로 업데이트하여 두 노드 사이의 최단 경로를 계산한다.</p>
<p><strong>인접 행렬</strong></p>
<p>가중 그래프의 인접 행렬은 노드와 노드를 잇는 간선과 가중치의 정보를 표현하는 <span class="math notranslate nohighlight">\(n\times n\)</span> 행렬이다.
여기서 <span class="math notranslate nohighlight">\(n\)</span>은 노드의 개수를 가리킨다.
인접 행렬은 다음과 같이 정의되는 <span class="math notranslate nohighlight">\(n\times n\)</span> 행렬 <span class="math notranslate nohighlight">\(W\)</span>로 표현된다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
W[i][j] = 
\begin{cases}
\text{간선 가중치} &amp; \quad\text{$v_i$ 에서 $v_j$ 로의 간선이 존재하는 경우} \\
\infty &amp; \quad\text{$v_i$ 에서 $v_j$ 로의 간선이 존재하지 않는 경우} \\
0 &amp; \quad \text{$i = j$ 인 경우}
\end{cases}
\end{split}\]</div>
<p>앞서 예제로 언급된 가중 방향 그래프의 인접 행렬은 다음과 같다.
단, <code class="docutils literal notranslate"><span class="pre">inf</span></code>는 두 노드 사이에 간선이 없는 경우를 가리키며
무한<font size='2'>infinity</font>을 의미한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 무한에 해당하는 기호 사용</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">inf</span>

<span class="c1"># inf 는 두 노드 사이에 간선이 없음을 의미함.</span>
<span class="n">W</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
     <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
     <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p><strong>동적계획법 전략</strong></p>
<p><span class="math notranslate nohighlight">\(v_i\)</span>에서 <span class="math notranslate nohighlight">\(v_j\)</span>로 가는 최단 경로를 계산하기 위해
경유 노드를 확대해 나가면서 최단 경로를 업데이트하는 전략을 사용한다.
이를 위해 <span class="math notranslate nohighlight">\(k\)</span>를 <span class="math notranslate nohighlight">\(0\)</span>부터 <span class="math notranslate nohighlight">\(n\)</span>까지 변하게 하면서 아래 조건에 맞는 행렬 <span class="math notranslate nohighlight">\(D^{(k)}\)</span>를
순차적으로 생성한다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
D^{(k)}[i][j] &amp;= \text{집합 $\{v_0, v_1, \dots, v_{k-1}\}$ 에 속하는 노드만을 경유해서} \\
&amp; \,\,\quad\,\text{$v_i$ 에서 $v_j$ 로 가는 최단 경로의 길이}
\end{align*}
\end{split}\]</div>
<p>먼저, <span class="math notranslate nohighlight">\(D^{(0)}= W\)</span>이 성립한다.
이유는 <span class="math notranslate nohighlight">\(k=0\)</span> 이면 <span class="math notranslate nohighlight">\(k-1=-1\)</span> 이고, 따라서 <span class="math notranslate nohighlight">\(\{v_0, v_1, \dots, v_{k-1}\}\)</span> 는 공집합으로 간주되기에
두 노드를 연결하는 경로를 찾을 때 어떤 다른 노드를 경유하지 않아야 하기 때문이다.
즉, 두 노드를 직접 연결하는 간선만 사용할 수 있다.</p>
<p>반면에 <span class="math notranslate nohighlight">\(D^{(n)}\)</span>은 두 노드 사이의 최단 경로의 길이로 구성된다.
이유는 최단 경로를 결정할 때 어떤 노드를 거쳐야 하는제 제한이 없기 때문이다.
이제 남은 과제는 “어떻게 <span class="math notranslate nohighlight">\(D^{(0)}\)</span>에서 출발하여 <span class="math notranslate nohighlight">\(D^{(n)}\)</span>을 계산할 것인가?” 이다.</p>
<p>먼저, 0보다 큰 <span class="math notranslate nohighlight">\(k\)</span>에 대해 <span class="math notranslate nohighlight">\(D^{(k)}[i][j]\)</span> 를 재귀적으로 정의할 수 있음에 주목한다.</p>
<div class="math notranslate nohighlight">
\[D^{(k)}[i][j] = \min \big( D^{(k-1)}[i][j],\,D^{(k-1)}[i][k] + D^{(k-1)}[k][j] \big)\]</div>
<p>이유는 다음과 같이 두 경우를 고려하면 되기 때문이다.</p>
<ul>
<li><p>경우 1</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\{v_0, v_1,\dots, v_{k-1}\}\)</span> 에 속한 노드들만을 통해서 <span class="math notranslate nohighlight">\(v_i\)</span>에서 <span class="math notranslate nohighlight">\(v_j\)</span>로 가는 최단 경로가 <span class="math notranslate nohighlight">\(v_{k-1}\)</span>를 경유하는 경우.</p></li>
<li><p><span class="math notranslate nohighlight">\(v_{k-1}\)</span>가 무시되기에 결국 <span class="math notranslate nohighlight">\(\{v_0, v_1,\dots, v_{k-2}\}\)</span> 만 경유하는 최단 거리와 동일함.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[D^{(k)}[i][j] = D^{(k-1)}[i][j]\]</div>
  <br>
</li>
<li><p>경우 2</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\{v_0, v_1,\dots, v_{k-1}\}\)</span> 에 속한 노드들만을 통해서 <span class="math notranslate nohighlight">\(v_i\)</span>에서 <span class="math notranslate nohighlight">\(v_j\)</span>로 가는 최단 경로가 <span class="math notranslate nohighlight">\(v_{k-1}\)</span>를 경유하지 않는 경우.</p></li>
<li><p>단순 경로만 고려해야 하기에 다음 <span class="math notranslate nohighlight">\(v_{k-1}\)</span>을 한 번만 경유하며 따라서 다음 식이 성립함.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[D^{(k)}[i][j] = D^{(k-1)}[i][k] + D^{(k-1)}[k][j]\]</div>
</li>
</ul>
<p>위 재귀적 성질을 동적계획법으로 구현하고자 한다.
먼저, 동적계획법의 적용과정을 예제를 이용하여 설명한다.
다음은 앞서 언급된 재귀적 성질을 이용하여 <span class="math notranslate nohighlight">\(D^{(k)}[1][4]\)</span>를 동적계획법으로 계산하는 과정을 보여준다.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(D^{(0)}[1][4] = W[1][4] = \infty\)</span></p></li>
</ul>
<ul>
<li><p><span class="math notranslate nohighlight">\(D^{(1)}[1][4] = \min (D^{(0)}[1][4], d^{(1)}) = \min(\infty, 14) = 14\)</span></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(d^{(1)}\)</span>은 <span class="math notranslate nohighlight">\(v_0\)</span>를 경유하는 최단 경로 길이:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d^{(1)} = D^{(0)}[1][0] + D^{(0)}[0][4] = 9+5 = 14\]</div>
</li>
</ul>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(D^{(2)}[1][4] = D^{(1)}[1][4] = 14\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(v_0\)</span>와 <span class="math notranslate nohighlight">\(v_1\)</span>을 경유할 수 있는 최단 경로 길이는 <span class="math notranslate nohighlight">\(v_0\)</span>를 경유할 수 있는 최단 경로 길이와 동일</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(D^{(3)}[1][4] = D^{(2)}[1][4] = 14\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(v_2\)</span>를 경유할 수 없음. 왜냐하면 <span class="math notranslate nohighlight">\(v_2\)</span>를 경유하면 반드시 <span class="math notranslate nohighlight">\(v_3\)</span>를
경유해야 하는데 그것이 허용되지 않기 때문임.</p></li>
</ul>
</li>
</ul>
<ul>
<li><p><span class="math notranslate nohighlight">\(D^{(4)}[1][4] = \min (D^{(3)}[1][4], d^{(4)}) = \min(14, 5) = 5\)</span>.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(d^{(4)}\)</span>는 <span class="math notranslate nohighlight">\(v_3\)</span>를 경유하는 최단 경로 길이:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d^{(3)} = D^{(3)}[1][3] + D^{(3)}[3][4] = 2 + 3 = 5\]</div>
</li>
</ul>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(D^{(5)}[1][4] = D^{(4)}[1][4] = 5\)</span></p>
<ul>
<li><p><span class="math notranslate nohighlight">\(v_4\)</span>는 최종 도착점이기 때문임.</p></li>
</ul>
</li>
</ul>
</section>
<section id="id4">
<h2><span class="section-number">19.3. </span>플로이드-워셜 알고리즘<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p><strong>플로이드-워셜</strong><font size='2'>Floyd-Warshall</font> 알고리즘은
앞서 설명한 동적계획법 전략으로 아래 화살표 과정을 구현하는 알고리즘이다.</p>
<div class="math notranslate nohighlight">
\[
W = D^{(0)} \longrightarrow D^{(1)}\longrightarrow D^{(2)}
\longrightarrow \cdots \longrightarrow D^{(n-1)}\longrightarrow D^{(n)} = D
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="c1"># 사전을 이용하여 D^(0), ... , D^(n) 저장</span>
    <span class="c1"># 키는 0, 1, ..., n 사용</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> 

    <span class="c1"># D^(0) 지정</span>
    <span class="c1"># 주의: deepcopy를 사용하지 않으면 W가 수정됨</span>
    <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>

    <span class="c1"># D^(k) 로부터 D^(k+1)를 생성</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># 행렬의 인덱스는 0부터 (n-1)까지 이동</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    
    <span class="c1"># 최종 완성된 D[n] 반환</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">floyd_warshall</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 1, 3, 1, 4],
 [8, 0, 3, 2, 5],
 [10, 11, 0, 4, 7],
 [6, 7, 2, 0, 3],
 [3, 4, 6, 4, 0]]
</pre></div>
</div>
</div>
</div>
<p><strong>얕은 복사 대 깊은 복사</strong></p>
<p>리스트의 <code class="docutils literal notranslate"><span class="pre">copy()</span></code> 메서드는 얕은 복사<font size='2'>shallow copy</font> 용도로 사용된다.
얕은 복사의 경우 단순 리스트일 경우 새로운 리스트를 복사해서 만들어 내지만
중첩 리스트인 경우 모든 것을 복사하지는 않는다.
아래 코드가 얕은 복사가 단순 리스트와 중첩 리스트의 다르게 작동함을 잘 보여준다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 얕은 복사</span>
<span class="n">aList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">bList</span> <span class="o">=</span> <span class="n">aList</span>
<span class="n">cList</span> <span class="o">=</span> <span class="n">aList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">aList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;얕은 복사:&quot;</span><span class="p">,</span> <span class="n">aList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">dList</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="n">eList</span> <span class="o">=</span> <span class="n">dList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">dList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;얕은 복사:&quot;</span><span class="p">,</span> <span class="n">dList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">eList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>얕은 복사: False
얕은 복사: True
</pre></div>
</div>
</div>
</div>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-13.png" width="800"/></div><p>중첩 리스트를 복사하려면 깊은 복사<font size='2'>deep copy</font>를 사용해야 한다.
아래 코드는 얕은 복사를 지원하는 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 모듈의 <code class="docutils literal notranslate"><span class="pre">copy()</span></code> 함수와 깊은
복사를 지원하는 <code class="docutils literal notranslate"><span class="pre">deepcopy()</span></code> 함수를 이용하여 깊은 복사가
얕은 복사와 다르게 작동함을 보여준다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 얕은 복사 vs. 얕은 복사</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>

<span class="n">aList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">bList</span> <span class="o">=</span> <span class="n">aList</span>
<span class="n">cList</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">aList</span><span class="p">)</span>
<span class="n">aList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;얕은 복사:&quot;</span><span class="p">,</span> <span class="n">aList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">dList</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="n">eList</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">dList</span><span class="p">)</span>
<span class="n">dList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;깊은 복사:&quot;</span><span class="p">,</span> <span class="n">dList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">eList</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>얕은 복사: False
깊은 복사: False
</pre></div>
</div>
</div>
</div>
<div align="center"><img src="https://raw.githubusercontent.com/codingalzi/algopy/master/jupyter-book/imgs/algo05/algo05-14.png" width="800"/></div><p><strong>시간 복잡도</strong></p>
<p>플로이드-워셜 알고리즘의 시간 복잡도를 계산하기 위해
기본 계산단위를 행렬의 항목을 계산하는 명령문으로 지정한다.
알고리즘 진행 과정은 다음과 같다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">D[0]</span></code>의 항목을 초기화하는 데에 <span class="math notranslate nohighlight">\(n^2\)</span>의 항목을 복사한다.</p></li>
<li><p>이후에 <code class="docutils literal notranslate"><span class="pre">D[k+1]</span></code>을 계산하기 위해 <code class="docutils literal notranslate"><span class="pre">D[k]</span></code>의 항목을 최대 <span class="math notranslate nohighlight">\(n^2\)</span> 번 업데이트 한다.
<code class="docutils literal notranslate"><span class="pre">D[k+1]</span></code>을 초기화할 때는 파이썬 언어의 특성상 새로운 리스트를 생성하지 않고 기존에 정의된 <code class="docutils literal notranslate"><span class="pre">D[k]</span></code>를 그대로 가리킨다.</p></li>
<li><p>업데이트를 <code class="docutils literal notranslate"><span class="pre">n</span></code> 번 반복하기에 최대 <span class="math notranslate nohighlight">\(n^3 + n^2\)</span> 번 항목을 계산한다.</p></li>
</ul>
<p>따라서 플로이드-워셜 알고리즘의 시간 복잡도는 <span class="math notranslate nohighlight">\(O(n^3)\)</span>이다.</p>
<p><strong>공간 복잡도</strong></p>
<p>위 코드만 보면 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> 모양의 행렬 <code class="docutils literal notranslate"><span class="pre">D[k]</span></code> 를 <code class="docutils literal notranslate"><span class="pre">n+1</span></code> 개 생성하는 것으로 보인다.
하지만 실제 메모리 상에서는 <code class="docutils literal notranslate"><span class="pre">D[0]</span></code> 행렬만 새로 생성하고
나머지 <code class="docutils literal notranslate"><span class="pre">D[k]</span></code>는 <code class="docutils literal notranslate"><span class="pre">D[k-1]</span></code> 의 항목을 직접 업데이트하는 방식으로 진행된다.
따라서 플로이드-워셜 알고리즘의 공간 복잡도는 <span class="math notranslate nohighlight">\(O(n^2)\)</span> 이다.
<a class="reference external" href="https://pythontutor.com/render.html#code=from%20copy%20import%20deepcopy%0A%0Adef%20floyd_warshall%28W%29%3A%0A%20%20%20%20n%20%3D%20len%28W%29%0A%20%20%20%20D%20%3D%20dict%28%29%20%0A%20%20%20%20D%5B0%5D%20%3D%20deepcopy%28W%29%0A%0A%20%20%20%20for%20k%20in%20range%280,%20n%29%3A%0A%20%20%20%20%20%20%20%20D%5Bk%2B1%5D%20%3D%20D%5Bk%5D%0A%20%20%20%20%20%20%20%20for%20i%20in%20range%280,%20n%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20j%20in%20range%280,%20n%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20D%5Bk%5D%5Bi%5D%5Bk%5D%2B%20D%5Bk%5D%5Bk%5D%5Bj%5D%20%3C%20D%5Bk%5D%5Bi%5D%5Bj%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20D%5Bk%2B1%5D%5Bi%5D%5Bj%5D%20%3D%20D%5Bk%5D%5Bi%5D%5Bk%5D%2B%20D%5Bk%5D%5Bk%5D%5Bj%5D%0A%20%20%20%20%0A%20%20%20%20return%20D%5Bn%5D%0A%20%20%20%20%0Afrom%20math%20import%20inf%0A%0AW%20%3D%20%5B%5B0,%201,%20inf,%201,%205%5D,%0A%20%20%20%20%20%5B9,%200,%203,%202,%20inf%5D,%0A%20%20%20%20%20%5Binf,%20inf,%200,%204,%20inf%5D,%0A%20%20%20%20%20%5Binf,%20inf,%202,%200,%203%5D,%0A%20%20%20%20%20%5B3,%20inf,%20inf,%20inf,%200%5D%5D%0A%20%20%20%20%20%0Afloyd_warshall%28W%29&amp;amp;cumulative=false&amp;amp;curInstr=0&amp;amp;heapPrimitives=nevernest&amp;amp;mode=display&amp;amp;origin=opt-frontend.js&amp;amp;py=311&amp;amp;rawInputLstJSON=%5B%5D&amp;amp;textReferences=false_">파이썬 튜터</a>에서 메모리 사용을 직접 확인할 수 있다.</p>
<p>참고로 <code class="docutils literal notranslate"><span class="pre">D[k+1][i][j]</span></code> 계산에 필요한 <code class="docutils literal notranslate"><span class="pre">D[k][i][k]</span></code>와 <code class="docutils literal notranslate"><span class="pre">D[k][k][j]</span></code> 가
각각 <code class="docutils literal notranslate"><span class="pre">D[k+1][i][k]</span></code>와 <code class="docutils literal notranslate"><span class="pre">D[k+1][k][j]</span></code>에 의해 먼저 업데이트될 가능성은 없다.
이유는 <code class="docutils literal notranslate"><span class="pre">D[k+1][i][k]</span></code> 와 <code class="docutils literal notranslate"><span class="pre">D[k][i][k]</span></code>, 그리고 <code class="docutils literal notranslate"><span class="pre">D[k+1][k][j]</span></code>와 <code class="docutils literal notranslate"><span class="pre">D[k+1][k][j]</span></code>는 동일하기 때문이다.</p>
<p><strong>최단 경로 확인 알고리즘</strong></p>
<p>이전 함수를 약간 수정하여 최단 경로를 출력하는 함수를 구현한다.
추가되어야 하는 사항은
두 노드 사이의 최단 경로에 사용된 노드 중에서 가장 큰 인덱스를 기억하는 행렬 <span class="math notranslate nohighlight">\(P\)</span>이다.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
P[i][j] =
\begin{cases}
k &amp; \quad\text{$v_i$ 에서 $v_j$ 로의 최단 경로의 경유지로 사용된} \\
  &amp; \quad\text{노드의 인덱스 중에서 가장 큰 값이 $k$} \\
  &amp; \\
-1 &amp; \quad\text{$v_i$ 에서 $v_j$ 로의 간선이 최단 경로이거나} \\
   &amp; \quad\text{두 노드 사이의 경로가 존재하지 않는 경우}
\end{cases}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="k">def</span> <span class="nf">floyd_warshall2</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="c1"># 사전을 이용하여 D^(0), ... , D^(n) 저장</span>
    <span class="c1"># 키는 0, 1, ..., n 사용</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> 

    <span class="c1"># 경로 기억 어레이</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="c1"># -1로 초기화</span>

    <span class="c1"># D^(0) 지정</span>
    <span class="c1"># 주의: deepcopy를 사용하지 않으면 W가 수정됨</span>
    <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>

    <span class="c1"># D^(k) 로부터 D^(k+1)를 생성</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># 행렬의 인덱스는 0부터 (n-1)까지 이동</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    
    <span class="c1"># 최종 완성된 D[n] 반환</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">P</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">D</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">floyd_warshall2</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">D</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 1, 3, 1, 4],
 [8, 0, 3, 2, 5],
 [10, 11, 0, 4, 7],
 [6, 7, 2, 0, 3],
 [3, 4, 6, 4, 0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[-1, -1, 3, -1, 3],
 [4, -1, -1, -1, 3],
 [4, 4, -1, -1, 3],
 [4, 4, -1, -1, -1],
 [-1, 0, 3, 0, -1]]
</pre></div>
</div>
</div>
</div>
<p><strong>최단 경로 찍어보기</strong></p>
<p>최단 경로 상에 위치한 노드를 리스트로 담을 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">route</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">r</span><span class="p">]</span>

        <span class="n">path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
        <span class="n">route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">route</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 3]
</pre></div>
</div>
</div>
</div>
<p>위 결과를 이용하여 경로를 보다 예쁘게 출력할 수 있다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="n">route</span> <span class="o">=</span> <span class="n">path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">route</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -&gt; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">route</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4 -&gt; 0 -&gt; 3 -&gt; 2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_path2</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 -&gt; 3 -&gt; 4
</pre></div>
</div>
</div>
</div>
</section>
<section id="id5">
<h2><span class="section-number">19.4. </span>최적의 원칙<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p>동적계획법에 의한 설계 절차는 일반적으로 다음 과정을 따른다.</p>
<ul class="simple">
<li><p>문제의 입력에 대해 최적의 해답을 제공하는 재귀 관계식을 설정한다.</p></li>
<li><p>상향식으로 작은 입력값에 대한 최적의 해답을 계산하여 최종적으로 최적의 해답을 구축한다.</p></li>
</ul>
<p>주어진 문제 사례에 대한 최적의 해가 그 사례를 분할한 모든 부분사례에 대한 최적의 해를 포함하고 있는 경우
최적의 원칙이 적용될 수 있다고 말한다.
동적계획법에 의해 얻어진 해답이 최적이 되려면 해당 문제에 대해 최적의 원칙이 적용될 수 있어야 한다.</p>
<p>최적의 원칙이 적용되는 예제와 그렇지 않은 예제를 하나씩 살펴 본다.</p>
<p><strong>예제: 최단 경로 문제</strong></p>
<p><span class="math notranslate nohighlight">\(v_k\)</span>가 <span class="math notranslate nohighlight">\(v_i\)</span>에서 <span class="math notranslate nohighlight">\(v_j\)</span>로 가는 단순 최단 경로 상에 위치하며 가장 큰 인덱스를 갖는 노드라고 하면,
<span class="math notranslate nohighlight">\(v_i\)</span>에서 <span class="math notranslate nohighlight">\(v_k\)</span> 로 가는 부분경로와 <span class="math notranslate nohighlight">\(v_k\)</span>에서 <span class="math notranslate nohighlight">\(v_j\)</span>로 가는 부분경로 또한
두 노드 사이의 최단 경로이다.
이유는 아래 식을 이용하여 두 노드 사이의 최단 경로가 계산되었기 때문이다.</p>
<div class="math notranslate nohighlight">
\[D^{(k)}[i][j] = \min \big( D^{(k-1)}[i][j],\,D^{(k-1)}[i][k] + D^{(k-1)}[k][j] \big)\]</div>
<p>결론적으로 최단 경로 문제를 해결하는 동적계획법 알고리즘은 최적의 원칙을 만족시킨다.</p>
<p><strong>예제: 최장 경로 문제</strong></p>
<p>아래 그래프에서 <span class="math notranslate nohighlight">\(v_0\)</span>에서 <span class="math notranslate nohighlight">\(v_3\)</span>로의 단순 최장 경로는 <span class="math notranslate nohighlight">\(v_0 \to v_2 \to v_1 \to v_3\)</span>이다.
그러나 이 경로의 부분 경로인 <span class="math notranslate nohighlight">\(v_0\)</span>에서 <span class="math notranslate nohighlight">\(v_2\)</span>으로의 비순환 최장 경로는
<span class="math notranslate nohighlight">\(v_0 \to v_2\)</span>가 아니라 <span class="math notranslate nohighlight">\(v_0 \to v_1\to v_2\)</span> 이다.
즉, 최장 경로 문제를 찾는 알고리즘은 최적의 원칙을 만족시키지 못한다.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digraph1</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">()</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="s2">&quot;v3&quot;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v0&quot;</span><span class="p">,</span> <span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="s2">&quot;v3&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;4&#39;</span><span class="p">)</span>
<span class="n">digraph1</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>

<span class="n">save_graph_as_svg</span><span class="p">(</span><span class="n">digraph1</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;weighted_directed_graph_02&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/6c5a5152b8a6850c192bf3f015e41a336ecb26ef2cac723ce6169487c6549e7a.svg" src="_images/6c5a5152b8a6850c192bf3f015e41a336ecb26ef2cac723ce6169487c6549e7a.svg" />
</div>
</div>
<p>이렇게 최적의 원칙이 어긋나는 알고리즘은 동적계획법으로 구현할 수 없다.
만약 동적 계획법으로 비순환 최장 경로를 생성하려 한다면 <span class="math notranslate nohighlight">\(v_0 \to v_1\to v_2\)</span>를 사용해야 하는데
그려면 <span class="math notranslate nohighlight">\(v_0\)</span>에서 <span class="math notranslate nohighlight">\(v_3\)</span>로의 비순환 최장 경로를 생성할 수 없기 때문이다.
결론적으로 동적 계획법으로 최적의 해를 얻기 위해서는 최적의 원칙이 성립해야 한다.</p>
</section>
<section id="id6">
<h2><span class="section-number">19.5. </span>연습 문제<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://colab.research.google.com/github/codingalzi/algopy/blob/master/excs/exc-dynamic_programming_2.ipynb">(실습) 플로이드-워셜 알고리즘</a></p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="dynamic_programming_1.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">18. </span>최적화 문제와 동적계획법</p>
      </div>
    </a>
    <a class="right-next"
       href="greedy_algorithm_1.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">20. </span>최소비용 신장트리</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">19.1. 그래프 용어</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">19.2. 최단 경로 문제</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">19.3. 플로이드-워셜 알고리즘</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">19.4. 최적의 원칙</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">19.5. 연습 문제</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By 코딩알지
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>